{
  "hash": "375b318e7772cda51d9ff3a4534d1212",
  "result": {
    "markdown": "---\ntitle: Composing macros inside-out with Julia\ndate: '2022-08-07'\n---\n\n### Macros vs. functions\n\nMacros in Julia, denoted by the `@` prefix, are used to transform code before it is executed.\nThey are often used to reduce boilerplate or implement domain specific languages (DSLs).\n\nIn a way, they are just normal functions which take in an abstract syntax tree or AST and return a different one, and their execution happens before that of all the normal code.\n\nWhile functions run inside-out, macros run outside-in.\nWhen you execute `outer(inner(x))` then the inner function runs first, and `outer` takes in what `inner` outputs.\nBut if you execute `@outer(@inner(x))`, then `@outer` runs first, only after which any remaining macros inside the AST it outputs are run.\nIn this example could still be `@inner` depending on what `@outer` outputs, but it doesn't have to be.\nFor example, there could be a `@remove_macros` macro, which just deletes any macro calls inside its body.\n\n### Macros don't compose\n\nOne problematic consequence of this is that macros do not really compose.\nFor example, let's say you have two macros that operate on function definitions and add some useful things to them.\n\nLet's make one which wraps the body of a function in a timing operation:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nmacro functime(expr)\n    expr.head == :function || error(\"Not a function expression.\")\n    funcname = expr.args[1].args[1]\n    :(\n        function $(esc(funcname))(args...; kwargs...)\n            f = $expr\n            println(\"Started execution at $(time())\")\n            result = f(args...; kwargs...)\n            println(\"Stopped execution at $(time())\")\n            return result\n        end\n    )\nend\n\n@functime function func()\n    sleep(0.5)\n    return \"result\"\nend\n\nfunc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarted execution at 1.659899778106047e9\nStopped execution at 1.659899778627272e9\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n\"result\"\n```\n:::\n:::\n\n\nAnd one that just logs that the function is being run:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nmacro funclog(expr)\n    expr.head == :function || error(\"Not a function expression.\")\n    funcname = expr.args[1].args[1]\n    :(\n        function $(esc(funcname))(args...; kwargs...)\n            f = $expr\n            @info(\"Running function.\")\n            result = f(args...; kwargs...)\n            return result\n        end\n    )\nend\n\n@funclog function func2()\n    sleep(0.5)\n    return \"result\"\nend\n\nfunc2()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: Running function.\n└ @ Main In[3]:7\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n\"result\"\n```\n:::\n:::\n\n\nBut you cannot use both macros at once on a single function definition, because each macro expects an expression in form of a function definition as its argument.\nAnd putting a different macro inside means that the expression is of type `:macrocall` and not type `:function`, which our macros don't know how to deal with.\n\nSo this doesn't work:\n\n```julia\n@functime @funclog function func3()\n    sleep(0.5)\n    return \"result\"\nend\n```\n\n### The inside-out macro\n\nWhat I wanted to try here was to make the macros expand inside-out, like functions.\nFor this, I made another small meta-macro which calls `macroexpand` from the inside out if it encounters multiple macros.\nThat means `@insideout @macro1 @macro2 expr` first expands `@macro2 expr` and then `@macro1 output_expr`.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nmacro insideout(exp)\n    function apply_macro(exp::Expr)\n        if exp isa Expr && exp.head == :macrocall\n            exp.args[3] = apply_macro(exp.args[3])\n            return macroexpand(@__MODULE__, exp)\n        else\n            return exp\n        end\n    end\n    \n    apply_macro(exp)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n@insideout (macro with 1 method)\n```\n:::\n:::\n\n\nThis means one can now compose macros:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n@insideout @functime @funclog function func3()\n    sleep(0.5)\n    return \"result\"\nend\n\nfunc3()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarted execution at 1.659899780834476e9\nStopped execution at 1.659899781339017e9\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: Running function.\n└ @ Main In[3]:7\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n\"result\"\n```\n:::\n:::\n\n\nThese examples are contrived but I wonder if someone can come up with a more interesting use-case for the technique.\n\nAt least it's fun trying it out with some of the usual macros to see  modify what happens in an interesting way:\n\nFor example, using `@show` on `@show`:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n@show @show 1 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 + 2 = 3\n#= In[6]:1 =# @show(1 + 2) = 3\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n3\n```\n:::\n:::\n\n\nvs. with the inside-out mode, which turns `@show` into a kind of macroexpand-and-run:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n@insideout @show @show 1 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 + 2 = 3\nbegin\n    Base.println(\"1 + 2 = \", Base.repr(begin\n                #= show.jl:1047 =#\n                local var\"#265#value\" = 1 + 2\n            end))\n    var\"#265#value\"\nend = 3\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n3\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}