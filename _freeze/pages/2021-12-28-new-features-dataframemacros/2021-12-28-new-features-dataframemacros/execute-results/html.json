{
  "hash": "533bce56e2526db739e92068a9f44a1f",
  "result": {
    "markdown": "---\npublished: 2021-12-28\ntitle: \"Multi-columns, shortcut strings and subset transformations in DataFrameMacros.jl v0.2\"\n---\n\n# Multi-columns, shortcut strings and subset transformations in DataFrameMacros.jl v0.2\n\n[DataFrameMacros.jl](https://github.com/jkrumbiegel/DataFrameMacros.jl) is a Julia package that makes it easier to manipulate DataFrames, by rewriting code into source-function-sink expressions that conform to DataFrames.jl's more verbose mini-language.\nIn version v0.2 (and v0.2.1) I have added a couple new features that are powerful, but not immediately obvious.\nThis post takes a closer look at the new functionality.\n\nThe new features are multi-column specifiers, shortcut strings for renaming and subset transformations.\n\n## Multi-column specifiers\n\nSo far, DataFrameMacros.jl only supported statements with single-column specifiers.\nFor example, `@select(df, :x + 1)` or `@combine(df, $column_variable * $2)`.\nThe expressions `:x`, `$column_variable` and `$2` all refer to one column each.\nThe underlying source-function-sink expression that DataFrameMacros.jl created was therefore always of the form `source => function => sink`.\nFor many tasks this is perfectly sufficient, but other times one wants to execute the same function over a set of similar or related columns.\n\nDataFrames.jl has a neat way to run the same function on a set of columns.\nThis is done by using the `.=>` operator, to broadcast over a set or sets of columns and create an array of `source => function => sink` expressions.\nFor example, you could compute the sum for each column in a DataFrame with `transform(df, names(df, All()) .=> sum)`, or in the recent v1.3 release even with `transform(df, All() .=> sum)`.\n\nNow, the trick that DataFrameMacros.jl v0.2.1 uses is to change the underlying representation from `source => function => sink` to `source(s) .=> function(s) .=> sink(s)`.\nThis doesn't break the existing functionality, because scalars in Julia broadcast just fine, so it's no problem to say something like `combine(df, :x .=> sum .=> \"y\")` - even though broadcasting doesn't add anything if only scalars participate.\n\nWhere it gets interesting is when collections of columns are used.\nWith the change to `source(s) .=> function(s) .=> sink(s)` you are now free to use column expressions that refer to multiple columns.\nThe only restriction is that the shapes of `source(s)`, `function(s)` and `sink(s)` have to be compatible for broadcasting.\n\nThere are multiple ways in which you can reference multiple columns at once, and they are closely related to what `x` can be in the function `names(df, x)`.\nFor example, `All()`, `Between(x, y)` and `Not(args...)` are now recognized directly as multi-column specifiers by DataFrameMacros, without having to mark them with the usual `$` sign.\nThen you can use any `Type` `T` marked by `$`, which selects all columns whose elements are subtypes of `T`, for example `$Real` or `$String`.\nYou can use a regex that selects all columns with matching names, for example `$(r\"a\")` for any column with the letter `a`.\nOf course it's also possible to just pass an array of column names, for example `$[\"a\", \"b\"]`.\n\nHere are a few practical examples:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DataFrameMacros\nusing DataFrames\nm = methods(show, (IO, MIME\"text/html\", DataFrame)); if !isempty(m) Base.delete_method(first(m)) end #hide\n\ndf = DataFrame(\n    name = [\"alice\", \"bob\", \"charlie\"],\n    age = [20, 31, 42],\n    country = [\"andorra\", \"brazil\", \"croatia\"],\n    salary = [9999, 6666, 3333],\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×4 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> name    </span><span class=\"ansi-bold\"> age   </span><span class=\"ansi-bold\"> country </span><span class=\"ansi-bold\"> salary </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> String  </span><span class=\"ansi-bright-black-fg\"> Int64 </span><span class=\"ansi-bright-black-fg\"> String  </span><span class=\"ansi-bright-black-fg\"> Int64  </span>\n─────┼─────────────────────────────────\n   1 │ alice       20  andorra    9999\n   2 │ bob         31  brazil     6666\n   3 │ charlie     42  croatia    3333</pre>\n```\n:::\n\n:::\n:::\n\n\nWe can transform both `String` columns at once and both `Int` columns at once, by using the `Type` multi-column specifier.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nx = @select df begin\n    uppercasefirst($String)\n    Float64($Int)\nend\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3×4 DataFrame\n Row │ name_uppercasefirst  country_uppercasefirst  age_Float64  salary_Float64 \n     │ String               String                  Float64      Float64        \n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Alice                Andorra                        20.0          9999.0\n   2 │ Bob                  Brazil                         31.0          6666.0\n   3 │ Charlie              Croatia                        42.0          3333.0\n```\n:::\n:::\n\n\nWe can try out the `All()` specifier by reversing the element order of each column.\nWe need the `@c` flag so `reverse` acts on each column vector and not each column element.\nThis works the same way with the `Between` and `Not` selectors.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n@select df @c reverse(All())\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×4 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> name_reverse </span><span class=\"ansi-bold\"> age_reverse </span><span class=\"ansi-bold\"> country_reverse </span><span class=\"ansi-bold\"> salary_reverse </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> String       </span><span class=\"ansi-bright-black-fg\"> Int64       </span><span class=\"ansi-bright-black-fg\"> String          </span><span class=\"ansi-bright-black-fg\"> Int64          </span>\n─────┼────────────────────────────────────────────────────────────\n   1 │ charlie                42  croatia                    3333\n   2 │ bob                    31  brazil                     6666\n   3 │ alice                  20  andorra                    9999</pre>\n```\n:::\n\n:::\n:::\n\n\nWe can combine multi-column specifiers with single-column specifiers, they can always broadcast together because scalars work together with any shape.\nFor example, let's say we have a column with tax rates and four columns with quarterly gains and we want to compute the quarterly taxes.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ndf = DataFrame(\n    year = [2019, 2020, 2021],\n    tax_rate = [0.19, 0.20, 0.21],\n    income_q1 = [2000, 3000, 4000],\n    income_q2 = [2100, 3100, 4100],\n    income_q3 = [2200, 3200, 4200],\n    income_q4 = [2300, 3300, 4300],\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×6 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> year  </span><span class=\"ansi-bold\"> tax_rate </span><span class=\"ansi-bold\"> income_q1 </span><span class=\"ansi-bold\"> income_q2 </span><span class=\"ansi-bold\"> income_q3 </span><span class=\"ansi-bold\"> income_q4 </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Int64 </span><span class=\"ansi-bright-black-fg\"> Float64  </span><span class=\"ansi-bright-black-fg\"> Int64     </span><span class=\"ansi-bright-black-fg\"> Int64     </span><span class=\"ansi-bright-black-fg\"> Int64     </span><span class=\"ansi-bright-black-fg\"> Int64     </span>\n─────┼─────────────────────────────────────────────────────────────\n   1 │  2019      0.19       2000       2100       2200       2300\n   2 │  2020      0.2        3000       3100       3200       3300\n   3 │  2021      0.21       4000       4100       4200       4300</pre>\n```\n:::\n\n:::\n:::\n\n\nThen we can simply multiply the tax rate with the four income columns at once, which we select with the `Between` selector.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n@select(df, :tax_rate * Between(3, 6))\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×4 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> tax_rate_income_q1_* </span><span class=\"ansi-bold\"> tax_rate_income_q2_* </span><span class=\"ansi-bold\"> tax_rate_income_q3_* </span><span class=\"ansi-bold\"> tax_r</span> ⋯\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Float64              </span><span class=\"ansi-bright-black-fg\"> Float64              </span><span class=\"ansi-bright-black-fg\"> Float64              </span><span class=\"ansi-bright-black-fg\"> Float</span> ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │                380.0                 399.0                 418.0        ⋯\n   2 │                600.0                 620.0                 640.0\n   3 │                840.0                 861.0                 882.0\n<span class=\"ansi-cyan-fg\">                                                                1 column omitted</span></pre>\n```\n:::\n\n:::\n:::\n\n\nAnother option to select the columns would be to use a regex.\nWe have to mark it with `$` so that DataFrameMacros knows to treat it as a column specifier.\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n@select(df, :tax_rate * $(r\"income\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×4 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> tax_rate_income_q1_* </span><span class=\"ansi-bold\"> tax_rate_income_q2_* </span><span class=\"ansi-bold\"> tax_rate_income_q3_* </span><span class=\"ansi-bold\"> tax_r</span> ⋯\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Float64              </span><span class=\"ansi-bright-black-fg\"> Float64              </span><span class=\"ansi-bright-black-fg\"> Float64              </span><span class=\"ansi-bright-black-fg\"> Float</span> ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │                380.0                 399.0                 418.0        ⋯\n   2 │                600.0                 620.0                 640.0\n   3 │                840.0                 861.0                 882.0\n<span class=\"ansi-cyan-fg\">                                                                1 column omitted</span></pre>\n```\n:::\n\n:::\n:::\n\n\nNow one issue is that the resulting column names are very ugly.\nWe could specify the new names directly as a vector.\nRemember that the expression is `source(s) .=> function(s) .=> sink(s)` so we can also broadcast a vector of sinks.\nThe string `\"taxes_q1\"` will be the sink associated with the first element from the regex selector, and so on. \n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n@select(df,\n    [\"taxes_q1\", \"taxes_q2\", \"taxes_q3\", \"taxes_q4\"] = :tax_rate * $(r\"income\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×4 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> taxes_q1 </span><span class=\"ansi-bold\"> taxes_q2 </span><span class=\"ansi-bold\"> taxes_q3 </span><span class=\"ansi-bold\"> taxes_q4 </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Float64  </span><span class=\"ansi-bright-black-fg\"> Float64  </span><span class=\"ansi-bright-black-fg\"> Float64  </span><span class=\"ansi-bright-black-fg\"> Float64  </span>\n─────┼────────────────────────────────────────\n   1 │    380.0     399.0     418.0     437.0\n   2 │    600.0     620.0     640.0     660.0\n   3 │    840.0     861.0     882.0     903.0</pre>\n```\n:::\n\n:::\n:::\n\n\nBut writing out strings like that is error prone, especially if the order of columns can change.\nSo it would be better to transform the original column names.\nDataFrames allows to use anonymous functions for this, the input for the function is a vector with all column names used in the expression.\nWe can split off the `\"q1\"` part from the second column in each expression (the income column) and prefix with `\"taxes_\"`:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n@select(df, (names -> \"taxes_\" * split(names[2], \"_\")[2]) = :tax_rate * $(r\"income\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×4 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> taxes_q1 </span><span class=\"ansi-bold\"> taxes_q2 </span><span class=\"ansi-bold\"> taxes_q3 </span><span class=\"ansi-bold\"> taxes_q4 </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Float64  </span><span class=\"ansi-bright-black-fg\"> Float64  </span><span class=\"ansi-bright-black-fg\"> Float64  </span><span class=\"ansi-bright-black-fg\"> Float64  </span>\n─────┼────────────────────────────────────────\n   1 │    380.0     399.0     418.0     437.0\n   2 │    600.0     620.0     640.0     660.0\n   3 │    840.0     861.0     882.0     903.0</pre>\n```\n:::\n\n:::\n:::\n\n\n### Broadcasting with more than one dimension\n\nYou are not technically limited to broadcasting one vector of columns with scalar columns, you can even evaluate two- or higher-dimensional grids of column combinations if you like.\nFor example, if you had two different tax rates and three income categories, you could compute all six tax columns with one expression.\nHere we extract the income columns first so we can make them into a row-vector with `permutedims`, which will form a 2D grid when broadcasted together with the column vector with the two tax columns.\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\ndf = DataFrame(\n    year = [2019, 2020, 2021],\n    tax_a = [0.19, 0.20, 0.21],\n    tax_b = [0.22, 0.23, 0.24],\n    income_a = [2000, 3000, 4000],\n    income_b = [2100, 3100, 4100],\n    income_c = [2200, 3200, 4200],\n)\n\nincome_cols = permutedims(names(df, r\"income\"))\n\n@select(df, $(r\"tax\") * $income_cols)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×6 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> tax_a_income_a_* </span><span class=\"ansi-bold\"> tax_b_income_a_* </span><span class=\"ansi-bold\"> tax_a_income_b_* </span><span class=\"ansi-bold\"> tax_b_income_b_* </span> ⋯\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Float64          </span><span class=\"ansi-bright-black-fg\"> Float64          </span><span class=\"ansi-bright-black-fg\"> Float64          </span><span class=\"ansi-bright-black-fg\"> Float64          </span> ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │            380.0             440.0             399.0             462.0  ⋯\n   2 │            600.0             690.0             620.0             713.0\n   3 │            840.0             960.0             861.0             984.0\n<span class=\"ansi-cyan-fg\">                                                               2 columns omitted</span></pre>\n```\n:::\n\n:::\n:::\n\n\nThe column names are again not ideal, which brings us to another new feature.\n\n## Shortcut strings for renaming\n\nOften, we want to give new columns names that are just simple combinations of column names used to compute them.\nIn the last example, a better name than `tax_a_income_a_*` could be `tax_a_on_income_b`.\n\nIf DataFrameMacros encounters a string literal as the sink which contains `\"{}\"`, `\"{1}\"` or `\"{2}\"` and up, it translates this into a renaming function that pastes the input column names at the respective locations.\nHere's the last example again with such a shortcut string:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n@select(df, \"{1}_on_{2}\" = $(r\"tax\") * $income_cols)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">3×6 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> tax_a_on_income_a </span><span class=\"ansi-bold\"> tax_b_on_income_a </span><span class=\"ansi-bold\"> tax_a_on_income_b </span><span class=\"ansi-bold\"> tax_b_on_incom</span> ⋯\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Float64           </span><span class=\"ansi-bright-black-fg\"> Float64           </span><span class=\"ansi-bright-black-fg\"> Float64           </span><span class=\"ansi-bright-black-fg\"> Float64       </span> ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │             380.0              440.0              399.0              46 ⋯\n   2 │             600.0              690.0              620.0              71\n   3 │             840.0              960.0              861.0              98\n<span class=\"ansi-cyan-fg\">                                                               3 columns omitted</span></pre>\n```\n:::\n\n:::\n:::\n\n\n## Subset transformations\n\nThe third new feature goes hand in hand with a new addition in DataFrames v1.3.\nNow you can call `transform!` or `select!` on the view returned by `subset(df, some_subset_expression, view = true)`, and this will mutate the underlying DataFrame only in the selected rows.\nIf new columns are added, all rows outside the subset are filled with `missing` values.\n\nIn base DataFrames, you need to first create a subset view, then mutate it, then continue on with the original DataFrame.\nHere's the DataFrame we start with\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\ndf = DataFrame(x = 1:4, y = 5:8)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">4×2 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> x     </span><span class=\"ansi-bold\"> y     </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Int64 </span><span class=\"ansi-bright-black-fg\"> Int64 </span>\n─────┼──────────────\n   1 │     1      5\n   2 │     2      6\n   3 │     3      7\n   4 │     4      8</pre>\n```\n:::\n\n:::\n:::\n\n\nNow we subset some rows and increment the y values by 10 there.\nWe also create new z values:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nsubset_view = subset(df, :x => ByRow(>=(3)), view = true)\ntransform!(\n    subset_view,\n    :y => ByRow(x -> x + 10) => :y,\n    :x => (x -> x * 3) => :z\n)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">4×3 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> x     </span><span class=\"ansi-bold\"> y     </span><span class=\"ansi-bold\"> z       </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Int64 </span><span class=\"ansi-bright-black-fg\"> Int64 </span><span class=\"ansi-bright-black-fg\"> Int64?  </span>\n─────┼───────────────────────\n   1 │     1      5 <span class=\"ansi-bright-black-fg\"> missing </span>\n   2 │     2      6 <span class=\"ansi-bright-black-fg\"> missing </span>\n   3 │     3     17        9\n   4 │     4     18       12</pre>\n```\n:::\n\n:::\n:::\n\n\nIn DataFrameMacros v0.2, you can now use a more convenient syntax that plays well with Chain.jl or other piping mechanisms, where you only want to use functions that return the DataFrame you work with, not a subset view.\nYou can simply pass a `@subset` expression to `@transform!` or `@select!` after the DataFrame argument.\nThis `@subset` expression doesn't take its own DataFrame argument as usual, that's implied to be the DataFrame that is being transformed.\nThe returned object after mutating the selected rows is the original DataFrame.\nYou can see how much more concise the same operation becomes:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\ndf = DataFrame(x = 1:4, y = 5:8)\n@transform!(df, @subset(:x >= 3), :y = :y + 10, :z = 3 * :x)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-bold\">4×3 DataFrame</span>\n<span class=\"ansi-bold\"> Row </span>│<span class=\"ansi-bold\"> x     </span><span class=\"ansi-bold\"> y     </span><span class=\"ansi-bold\"> z       </span>\n<span class=\"ansi-bold\">     </span>│<span class=\"ansi-bright-black-fg\"> Int64 </span><span class=\"ansi-bright-black-fg\"> Int64 </span><span class=\"ansi-bright-black-fg\"> Int64?  </span>\n─────┼───────────────────────\n   1 │     1      5 <span class=\"ansi-bright-black-fg\"> missing </span>\n   2 │     2      6 <span class=\"ansi-bright-black-fg\"> missing </span>\n   3 │     3     17        9\n   4 │     4     18       12</pre>\n```\n:::\n\n:::\n:::\n\n\n## Summary\n\nThat concludes the overview of the three new features, multi-column specifiers, shortcut strings for renaming and subset transformations.\nEspecially multi-column specifiers with their implicit broadcasting might need a moment to wrap your head around, but I think you'll find them very convenient.\nI hope you enjoy using the new release!\n\n",
    "supporting": [
      "2021-12-28-new-features-dataframemacros_files"
    ],
    "filters": [],
    "includes": {}
  }
}