{
  "hash": "fc1bba4469b9eaa4b208bc75478a6d85",
  "result": {
    "markdown": "---\ntitle: \"Pkg.jl and Julia Environments for Beginners\"\ndate: 2022-08-27\ncategories: [\"julia\"]\n---\n\nWhen you start using Julia, you will quickly come in contact with Pkg.jl, its package manager.\nIt's reasonably easy to install a few packages and start using Julia.\nBut from reading questions on Slack and Discourse, many users only start understanding relatively late what commands like `instantiate` are doing.\nThis post should teach you how you can step beyond a messy global environment and towards neatly packaged local versions that allow you to collaborate more effectively and make your results reproducible.\n\n## Getting started\n\nWhen you install Julia for the first time, there are no environments.\nLet's say you installed Julia 1.8.\nWhen you start the REPL with the `julia` command, you will see the standard prompt\n\n\n\n```{html terminal}\n\n<span>hi</span>\n```\n\n\nFrom there, you get to the Pkg.jl REPL mode by typing `]`.\nThe prompt will change to indicate this, by showing the name of the active environment:\n\n```julia\n(@v1.8) pkg>\n```\n\nBut wait, didn't I just say there are no environments, yet?\nThat's true, there shouldn't be any environment files on your computer.\nYou can check the `.julia/environments` folder, it should be empty.\nThis folder contains all your \"shared\" environments.\nYou can tell that an environment is shared by the leading `@` character in the package REPL prompt, in our case `@v1.8` because we use Julia 1.8.\n\n(Note that if you already have a folder called `v1.8`, or whatever Julia version you're using, you can just rename that to `v1.8_deactivated` or something and restart Julia for the purposes of this tutorial.)\n\nIf a new environment is activated, this doesn't yet create any files, and that's why we don't have any files in `.julia/environments`, yet.\nThey only appear once you actually do something with your environment.\n\nWe can test this quickly.\nActivate a new environment by typing `(@v1.8) pkg> activate MyEnvironment`.\nYou won't see any new files being created in your working directory, as I said this only happens once you manipulate an environment.\nBut the prompt will have changed:\n\n```julia\n(@v1.8) pkg> activate MyEnvironment\n  Activating new project at `~/MyEnvironment`\n\n(MyEnvironment) pkg>\n```\n\nLet's switch back to the \"main\" environment `@v1.8` for now.\n\nThe purpose of shared environments is that you can activate them easily from any working directory because they start with `@`, and Pkg knows to look for them in `.julia/environments`.\nFor all other environments, you can activate them by name if you are in the directory where they were created, or you have to specify the full path.\n\nSo we activate `@v1.8` again by typing:\n\n```julia\n(MyEnvironment) pkg> activate @v1.8\n  Activating new project at `~/.julia/environments/v1.8`\n\n(@v1.8) pkg>\n```\n\nAs you see, Pkg told us we were activating a new project (another word for environment), because as we saw before, no files did actually exist, yet.\n\nThere's another shortcut to activate the main environment, which is `activate` without an argument:\n\n```julia\n(@v1.8) pkg> activate\n  Activating new project at `~/.julia/environments/v1.8`\n\n(@v1.8) pkg>\n```\n\n## Adding a package\n\nLet's add our first package to our shared `@v1.8` environment.\nFor this, we use the `add` command.\nI choose the `MacroTools` package because it has few dependencies.\n\n```julia\n(@v1.8) pkg> add MacroTools\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [1914dd2f] + MacroTools v0.5.9\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [1914dd2f] + MacroTools v0.5.9\n  [2a0f44e3] + Base64\n  [d6f4376e] + Markdown\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization\n```\n\nAs you probably know, after doing this, the `MacroTools` code has been downloaded onto your system and you can use it in your own code:\n\n```julia\njulia> using MacroTools\n```\n\nSo what actually happened when we ran the `add` command?\n\nIn the first line, you can see that the general registry was updated.\nThe general registry ([https://github.com/JuliaRegistries/General](https://github.com/JuliaRegistries/General)) is a list of third-party packages that are available to the public, where each package lists all its dependencies and versions.\nThere can be other registries, even private ones, but the general registry is the main one which will be the only one relevant for most users.\n\nPkg has first updated this list on our computer when we ran `add MacroTools` so that it knows about the most recent versions of all packages in the ecosystem.\nYou can have a look at it in `.julia/registries/` if you want.\n\nAfter updating the registry, Pkg is `Resolving package versions`.\nFirst, `MacroTools` latest version at the time of writing, `v0.5.9`, was added to `~/.julia/environments/v1.8/Project.toml`.\nSo at this point in time, finally the environment file I was talking about earlier is being created.\n\nWe can look at the content of `Project.toml`:\n\n```toml\n[deps]\nMacroTools = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\n```\n\nSo this just says that our environment has one dependency declared, which is `MacroTools.jl`.\nThe UUID string `1914dd2f-81c6...` is there because that's the \"real\" unique identifier of the package because, e.g., if another hypothetical registry had a different `MacroTools`, then at least you could specify the one you really want via the UUID.\n\nPkg also updated the file `~/.julia/environments/v1.8/Manifest.toml`.\nLet's have a look at this one:\n\n```toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.8.0-rc3\"\nmanifest_format = \"2.0\"\nproject_hash = \"e39ab6d265da4acedccb7411db33219b8d7db4fc\"\n\n[[deps.Base64]]\nuuid = \"2a0f44e3-6c83-55bd-87e4-b1978d98bd5f\"\n\n[[deps.MacroTools]]\ndeps = [\"Markdown\", \"Random\"]\ngit-tree-sha1 = \"3d3e902b31198a27340d0bf00d6ac452866021cf\"\nuuid = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\nversion = \"0.5.9\"\n\n[[deps.Markdown]]\ndeps = [\"Base64\"]\nuuid = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\n\n[[deps.Random]]\ndeps = [\"SHA\", \"Serialization\"]\nuuid = \"9a3f8284-a2c9-5f02-9a11-845980a1fd5c\"\n\n[[deps.SHA]]\nuuid = \"ea8e919c-243c-51af-8825-aaa63cd721ce\"\nversion = \"0.7.0\"\n\n[[deps.Serialization]]\nuuid = \"9e88b42a-f829-5b0c-bbe9-9e923198166b\"\n```\n\nThe `Manifest.toml` lists all the packages that were actually installed for you, while the `Project.toml` only lists the `MacroTools` dependency.\n\nYou can think of the two files this way:\n\n  - `Project.toml`: What you want.\n  - `Manifest.toml`: What you get.\n\nThe `Project.toml` is always the first file being edited when you make environment changes, if that is through the Pkg REPL or manually.\nThe `Manifest.toml` is then the result of a computation that tries to find compatible versions of all packages specified in the `Project.toml` and their dependencies.\nNote that `Project.toml` can in principle specify impossible demands, like two packages that require incompatible dependencies.\nA `Manifest.toml` however should always be in a valid state, if no valid configuration of package dependencies can be resolved, you will just get an error.\n\nWe can see the dependency graph that Pkg resolved in the `Manifest.toml`, if we look at the `deps` fields:\n\n\n```{dot}\ndigraph G {\n  MacroTools -> Markdown\n  MacroTools -> Random\n  Markdown -> Base64\n  Random -> SHA\n  Random -> Serialization\n  MacroTools [label=\"MacroTools v0.5.9\", style=filled, fillcolor=\"slategray2\"]\n  SHA [label=\"SHA v0.7.0\", style=filled, fillcolor=\"slategray2\"]\n  Markdown [style=filled, fillcolor=\"tomato\"]\n  Random [style=filled, fillcolor=\"tomato\"]\n  Serialization [style=filled, fillcolor=\"tomato\"]\n  Base64 [style=filled, fillcolor=\"tomato\"]\n}\n```\n\n\nThe blue nodes have versions and the red ones do not, that's because the red ones are standard libraries.\nStandard libraries are shipped with Julia, so they don't have their own version.\nThey only change with each Julia release.\nBut as you can see, even standard libraries can depend on other, even, external packages, as SHA is not a normal standard library (it's hosted externally) and has a version.\n\nYou can check the versions of libraries in your `Project.toml` and `Manifest.toml` with the `status` or `st` command.\nWith the `-m` flag you can see the `Manifest.toml` entries, which can be important for checking which dependencies were resolved.\n\n```julia\n(@v1.8) pkg> st\nStatus `~/.julia/environments/v1.8/Project.toml`\n  [1914dd2f] MacroTools v0.5.9\n\n(@v1.8) pkg> st -m\nStatus `~/.julia/environments/v1.8/Manifest.toml`\n  [1914dd2f] MacroTools v0.5.9\n  [2a0f44e3] Base64\n  [d6f4376e] Markdown\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n\n(@v1.8) pkg> st -m SHA\nStatus `~/.julia/environments/v1.8/Manifest.toml`\n  [ea8e919c] SHA v0.7.0\n```\n\n## Version numbers\n\nTo understand how dependencies are resolved, you have to understand [SemVer versioning](https://semver.org).\nSemVer stands for semantic versioning, which just means that version numbers should be meaningful, not just random labels.\nThe three parts of the version number are `major`.`minor`.`patch`.\nIn Julia, all newer versions with the same major version should have compatible public APIs, so code that works with `v1.2.3` should also work with `v1.20.5`.\nThe exception is major version `0`, where each new minor version can be considered potentially breaking.\nSo code that works with `v0.2.4` should still work with `v0.2.13` but not necessarily with `v0.3.0`.\nThis is because package developers want to be able to make breaking changes even if they haven't brought their package to `v1.0` yet, a version that usually carries the implication of public API stability and is often reached only after the package has been around for a while.\n\n## Adding specific variants of a package\n\nSo far, we have only used the command `add MacroTools`, which pulled the latest version `v0.5.9` into our environment.\nSometimes, however, you want a specific variant of a package.\nThat doesn't necessarily have to be a specific version.\nIt can also be a commit or branch of a certain repository.\nLet's try this out with `MacroTools`.\n\nWe can install the version `v0.5.1` by using the `@` syntax:\n\n```julia\n(@v1.8) pkg> add MacroTools@0.5.1\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n⌃ [1914dd2f] ↓ MacroTools v0.5.9 ⇒ v0.5.1\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n⌅ [00ebfdb7] + CSTParser v2.5.0\n⌅ [34da2185] + Compat v2.2.1\n⌅ [864edb3b] + DataStructures v0.17.20\n⌃ [1914dd2f] ↓ MacroTools v0.5.9 ⇒ v0.5.1\n  [bac558e1] + OrderedCollections v1.4.1\n  [0796e94c] + Tokenize v0.5.24\n  [0dad84c5] + ArgTools v1.1.1\n  [56f22d72] + Artifacts\n  [ade2ca70] + Dates\n  [8bb1440f] + DelimitedFiles\n  [8ba89e20] + Distributed\n  [f43a241f] + Downloads v1.6.0\n  [7b1f6079] + FileWatching\n  [b77e0a4c] + InteractiveUtils\n  [b27032c2] + LibCURL v0.6.3\n  [76f85450] + LibGit2\n  [8f399da3] + Libdl\n  [37e2e46d] + LinearAlgebra\n  [56ddb016] + Logging\n  [a63ad114] + Mmap\n  [ca575930] + NetworkOptions v1.2.0\n  [44cfe95a] + Pkg v1.8.0\n  [de0858da] + Printf\n  [3fa0cd96] + REPL\n  [1a1011a3] + SharedArrays\n  [6462fe0b] + Sockets\n  [2f01184e] + SparseArrays\n  [10745b16] + Statistics\n  [fa267f1f] + TOML v1.0.0\n  [a4e569a6] + Tar v1.10.0\n  [8dfed614] + Test\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\n  [e66e0078] + CompilerSupportLibraries_jll v0.5.2+0\n  [deac9b47] + LibCURL_jll v7.83.1+1\n  [29816b5a] + LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] + MbedTLS_jll v2.28.0+0\n  [14a3606d] + MozillaCACerts_jll v2022.2.1\n  [4536629a] + OpenBLAS_jll v0.3.20+0\n  [83775a58] + Zlib_jll v1.2.12+3\n  [8e850b90] + libblastrampoline_jll v5.1.1+0\n  [8e850ede] + nghttp2_jll v1.47.0+0\n  [3f19e933] + p7zip_jll v17.4.0+0\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated -m`\n```\n\nYou can see that we got a ton of new dependencies.\nThis happened because `MacroTools` managed to cut the number of packages it depends on a lot over time, so the older version pulls in much more.\n\nIf we take a look at the new `Manifest.toml` entry for `MacroTools`, we see:\n\n```toml\n[[deps.MacroTools]]\ndeps = [\"CSTParser\", \"Compat\", \"DataStructures\", \"Test\", \"Tokenize\"]\ngit-tree-sha1 = \"d6e9dedb8c92c3465575442da456aec15a89ff76\"\nuuid = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\nversion = \"0.5.1\"\n```\n\nThis just goes to show that even between patch versions of a package, which should all follow the same public API, the dependencies can change a lot.\n\nIf you look at the `Project.toml`, you will see that it hasn't changed.\nThe version requirement was just enforced during this one dependency resolution, and won't be remembered or enforced again in future Pkg operations.\n\nLet's try one other syntax, which is the one for choosing a specific commit or branch from a repository.\nIn this case, we use the commit `639d1a6`, but we could also use something like `master` to fetch the latest commit on that branch.\n\n```julia\n(@v1.8) pkg> add MacroTools#639d1a6\n     Cloning git-repo `https://github.com/FluxML/MacroTools.jl.git`\n    Updating git-repo `https://github.com/FluxML/MacroTools.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [1914dd2f] ~ MacroTools v0.5.1 ⇒ v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [00ebfdb7] - CSTParser v2.5.0\n  [34da2185] - Compat v2.2.1\n  [864edb3b] - DataStructures v0.17.20\n  [1914dd2f] ~ MacroTools v0.5.1 ⇒ v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`\n  [bac558e1] - OrderedCollections v1.4.1\n  [0796e94c] - Tokenize v0.5.24\n  [0dad84c5] - ArgTools v1.1.1\n  [56f22d72] - Artifacts\n  [ade2ca70] - Dates\n  [8bb1440f] - DelimitedFiles\n  [8ba89e20] - Distributed\n  [f43a241f] - Downloads v1.6.0\n  [7b1f6079] - FileWatching\n  [b77e0a4c] - InteractiveUtils\n  [b27032c2] - LibCURL v0.6.3\n  [76f85450] - LibGit2\n  [8f399da3] - Libdl\n  [37e2e46d] - LinearAlgebra\n  [56ddb016] - Logging\n  [a63ad114] - Mmap\n  [ca575930] - NetworkOptions v1.2.0\n  [44cfe95a] - Pkg v1.8.0\n  [de0858da] - Printf\n  [3fa0cd96] - REPL\n  [1a1011a3] - SharedArrays\n  [6462fe0b] - Sockets\n  [2f01184e] - SparseArrays\n  [10745b16] - Statistics\n  [fa267f1f] - TOML v1.0.0\n  [a4e569a6] - Tar v1.10.0\n  [8dfed614] - Test\n  [cf7118a7] - UUIDs\n  [4ec0a83e] - Unicode\n  [e66e0078] - CompilerSupportLibraries_jll v0.5.2+0\n  [deac9b47] - LibCURL_jll v7.83.1+1\n  [29816b5a] - LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] - MbedTLS_jll v2.28.0+0\n  [14a3606d] - MozillaCACerts_jll v2022.2.1\n  [4536629a] - OpenBLAS_jll v0.3.20+0\n  [83775a58] - Zlib_jll v1.2.12+3\n  [8e850b90] - libblastrampoline_jll v5.1.1+0\n  [8e850ede] - nghttp2_jll v1.47.0+0\n  [3f19e933] - p7zip_jll v17.4.0+0\nPrecompiling project...\n  ✓ MacroTools\n  1 dependency successfully precompiled in 1 seconds\n  1 dependency precompiled but a different version is currently loaded. Restart julia to access the new version\n```\n\nNote that even though the version printed for MacroTools is again `0.5.9`, this doesn't necessarily mean that we are on the same commit as the one pointed to by the version `0.5.9` in the registry.\nIt just means that Pkg cloned the repository, checked out the commit with hash `639d1a6` and found the version specifier `0.5.9` in MacroTools's own `Project.toml` file.\nTherefore, infinitely many code versions of a package can be treated as version `X.Y.Z` by Pkg, but `X.Y.Z` itself refers only to exactly one version.\nThis distinction is important to remember when developing and editing a package, but more about that later.\n\nIf we take another look at our `Manifest.toml`, we can see the following entry for MacroTools:\n\n```toml\n[[deps.MacroTools]]\ndeps = [\"Markdown\", \"Random\"]\ngit-tree-sha1 = \"465a4803356bcb11f6eb97df992680f13a9ba776\"\nrepo-rev = \"639d1a6\"\nrepo-url = \"https://github.com/FluxML/MacroTools.jl.git\"\nuuid = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\nversion = \"0.5.9\"\n```\n\nThis time, the URL of the repository was recorded, as well as the revision, which was `639d1a6`.\nThis is because as soon as you specify a revision in the `add` command, Pkg knows you're operating outside of the registry, so it cannot rely on the repository information stored there for MacroTools.\n\n(Note that you can also install unregistered packages, or forks of registered packages this way, by doing `add https://the_url_to_the_git_repository`.)\n\nThe manifest needs to store the url and revision in order to make the project reproducible by someone else.\nLet's actually look at what reproducing an environment looks like:\n\n## Reproducing an environment\n\nLet's say you have written some code relying on the specific `MacroTools` version we added via `add MacroTools#639d1a6` and want your colleague to be able to run that code with the exact packages installed that we used at the time.\n\nWhich files do they need to reproduce the state of your environment?\nNot just the `Project.toml`, because remember, it still only contains this information:\n\n```julia\n[deps]\nMacroTools = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\n```\n\nWe need to also send the `Manifest.toml` because it records the exact versions of all packages.\nLet's pretend we are our colleague, and we just received a `Project.toml` and `Manifest.toml` file.\nHow do we actually get the environment installed?\n\nLet's copy the files into a new folder we call `ColleagueEnv` in our current working directory.\n\nTo pretend we're the colleague who just uses Julia for the first time, we also delete the `.julia/packages/MacroTools` folder in which the downloaded source code of `MacroTools` was stored.\n\nNote that this means that the source code is not part of an environment but stored centrally.\nIt would be pretty wasteful to download the same sources over and over just because you're using different local environments.\n\nLet's now restart Julia and activate the `ColleagueEnv` environment:\n\n```julia\n(@v1.8) pkg> activate ./ColleagueEnv\n  Activating project at `~/ColleagueEnv`\n```\n\nWe can check the installed packages via `st -m`:\n\n```julia\n(ColleagueEnv) pkg> st -m\nStatus `~/ColleagueEnv/Manifest.toml`\n→ [1914dd2f] MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#master`\n  [2a0f44e3] Base64\n  [d6f4376e] Markdown\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\nInfo Packages marked with → are not downloaded, use `instantiate` to download\n```\n\nIf we were trying to just run some code using `MacroTools` now, this would happen:\n\n```julia\njulia> using MacroTools\nERROR: ArgumentError: Package MacroTools [1914dd2f-81c6-5fcd-8719-6d5c9610ff09] is required but does not seem to be installed:\n - Run `Pkg.instantiate()` to install all recorded dependencies.\n```\n\nSo we need to follow the advice already printed twice for us, and call `instantiate`.\nThis will download everything specified in the `Manifest.toml` exactly as it was recorded there.\nYou can actually be sure that it's exactly the same because the `Manifest.toml` stores git tree hashes of each dependency.\nUnless someone deletes these specific parts of the repository you will be able to download the source exactly as it was:\n\n```julia\n(ColleagueEnv) pkg> instantiate\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds\n\n(ColleagueEnv) pkg> st -m\nStatus `~/ColleagueEnv/Manifest.toml`\n  [1914dd2f] MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#master`\n  [2a0f44e3] Base64\n  [d6f4376e] Markdown\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n```\n\nNow we don't get a warning anymore, our dependencies have been downloaded correctly.\nYou will find `MacroTools` downloaded into the `.julia/packages` folder again.\n\n## Packages and environments\n\nPackages and normal environments are pretty similar.\nEach package must have a `Project.toml` which specifies its name, UUID, version and dependencies.\nThe easiest way to make a package to test this out, is to use the `generate` command of the Pkg REPL.\n\nLet's first remove `MacroTools` from our main environment so it is empty:\n\n```julia\n(@v1.8) pkg> rm MacroTools\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [1914dd2f] - MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [1914dd2f] - MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`\n  [2a0f44e3] - Base64\n  [d6f4376e] - Markdown\n  [9a3f8284] - Random\n  [ea8e919c] - SHA v0.7.0\n  [9e88b42a] - Serialization\n```\n\nNow, we generate a new package called `MyPackage`:\n\n```julia\n(@v1.8) pkg> generate MyPackage\n  Generating  project MyPackage:\n    MyPackage/Project.toml\n    MyPackage/src/MyPackage.jl\n```\n\nAs you can see, a `Project.toml` file was generated in the `MyPackage` directory.\n\nLet's have a look at this one:\n\n```toml\nname = \"MyPackage\"\nuuid = \"ac28244f-b540-4f11-9028-3fbea21f5993\"\nauthors = [\"Your Name <your@email.com>\"]\nversion = \"0.1.0\"\n```\n\nThe only difference from a basic package environment to a normal environment are those four fields.\nIf we want to use `MacroTools` in our package, we can add it manually to a `deps` section in the `Project.toml`, or we use the Pkg REPL.\nFor that, we first activate the package as an environment, then we add `MacroTools`.\n\n```julia\n(@v1.8) pkg> activate MyPackage/\n  Activating project at `~/MyPackage`\n\n(MyPackage) pkg> add MacroTools\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n   Installed MacroTools ─ v0.5.9\n    Updating `~/MyPackage/Project.toml`\n  [1914dd2f] + MacroTools v0.5.9\n    Updating `~/MyPackage/Manifest.toml`\n  [1914dd2f] + MacroTools v0.5.9\n  [2a0f44e3] + Base64\n  [d6f4376e] + Markdown\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization\nPrecompiling project...\n  2 dependencies successfully precompiled in 2 seconds\n\n(MyPackage) pkg>\n```\n\nThe `Project.toml` now looks like this:\n\n```toml\nname = \"MyPackage\"\nuuid = \"ac28244f-b540-4f11-9028-3fbea21f5993\"\nauthors = [\"Your Name <your@email.com>\"]\nversion = \"0.1.0\"\n\n[deps]\nMacroTools = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\n```\n\nIn the file `MyPackage/src/MyPackage.jl`, we can now import `MacroTools` and work with it.\nLet's change the content of that file to:\n\n```julia\nmodule MyPackage\n\nimport MacroTools\n\nfunction test()\n    MacroTools.@capture :(1 + 2) x_ + y_\n    @show x\n    @show y\n    return\nend\n\nend # module MyPackage\n```\n\nWe can now `import` or `using` our package and verify that `MacroTools` can be used by its source code:\n\n```julia\njulia> using MyPackage\n[ Info: Precompiling MyPackage [ac28244f-b540-4f11-9028-3fbea21f5993]\n\njulia> MyPackage.test()\nx = 1\ny = 2\n```\n\nThat worked!\n\nLet's restart Julia now, which will bring us back to the main environment.\nLet's try again to import our package:\n\n```julia\njulia> using MyPackage\nERROR: ArgumentError: Package MyPackage not found in current path.\n- Run `import Pkg; Pkg.add(\"MyPackage\")` to install the MyPackage package.\nStacktrace:\n [1] macro expansion\n   @ ./loading.jl:1163 [inlined]\n [2] macro expansion\n   @ ./lock.jl:223 [inlined]\n [3] require(into::Module, mod::Symbol)\n   @ Base ./loading.jl:1144\n```\n\nThis doesn't work, because our main environment doesn't have `MyPackage` installed.\nYou can use `MyPackage` as long as you have its own environment activated, but outside of that it is not visible.\n\nWe can change that by using the `develop` or `dev` command of the Pkg REPL, which will install and track `MyPackage`:\n\n```julia\n(@v1.8) pkg> dev ./MyPackage/\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [ac28244f] + MyPackage v0.1.0 `../../../MyPackage`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [1914dd2f] + MacroTools v0.5.9\n  [ac28244f] + MyPackage v0.1.0 `../../../MyPackage`\n  [2a0f44e3] + Base64\n  [d6f4376e] + Markdown\n  [9a3f8284] + Random\n  [ea8e919c] + SHA v0.7.0\n  [9e88b42a] + Serialization\n```\n\nGreat, that worked.\nNow we can access `MyPackage` again:\n\n```julia\njulia> using MyPackage\n[ Info: Precompiling MyPackage [ac28244f-b540-4f11-9028-3fbea21f5993]\n\njulia> MyPackage.test()\nx = 1\ny = 2\n```\n\nWhy would we want to do this, use a separate environment to access our package environment?\nIt's because we might want to use packages that should not be dependencies of `MyPackage` while developing it.\n\n## Compatibility bounds\n\nCurrently our package `MyPackage` does not specify the versions of `MacroTools` with which it is compatible.\nThat is usually not a good idea, in fact, the general registry doesn't allow packages to be registered if they don't specify upper compatibility boundaries for each dependency.\nThat makes sense because you don't know if your package will be compatible with all future versions of your dependencies, so it makes sense to cap the compatibility to the point where you have tested everything works.\n\nLet's pretend we tested our package only up to `MacroTools` version `0.5.8`.\nWe can write this requirement into the `Project.toml` of `MyPackage`:\n\n```toml\nname = \"MyPackage\"\nuuid = \"ac28244f-b540-4f11-9028-3fbea21f5993\"\nauthors = [\"Your Name <your@email.com>\"]\nversion = \"0.1.0\"\n\n[deps]\nMacroTools = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\n\n[compat]\nMacroTools = \"<0.5.9\"\n```\n\nBut this change is not picked up automatically by the `@v1.8` environment.\nTo recompute the dependency graph and throw away the old `Manifest.toml`, we can run `update` or `up`:\n\n```julia\n(@v1.8) pkg> up\n    Updating registry at `~/.julia/registries/General.toml`\n   Installed MacroTools ─ v0.5.8\n  No Changes to `~/.julia/environments/v1.8/Project.toml`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n⌃ [1914dd2f] ↓ MacroTools v0.5.9 ⇒ v0.5.8\n        Info Packages marked with ⌃ have new versions available\n```\n\nAs you can see, the MacroTools package was correctly downgraded to `v0.5.8`.\n\nWhat would happen if we now tried to install `v0.5.9` into the main environment?\n\n```julia\n(@v1.8) pkg> add MacroTools@0.5.9\n   Resolving package versions...\nERROR: Unsatisfiable requirements detected for package MacroTools [1914dd2f]:\n MacroTools [1914dd2f] log:\n ├─possible versions are: 0.4.3-0.5.9 or uninstalled\n ├─restricted to versions 0.0.0-0.5.8 by MyPackage [ac28244f], leaving only versions 0.4.3-0.5.8\n │ └─MyPackage [ac28244f] log:\n │   ├─possible versions are: 0.1.0 or uninstalled\n │   └─MyPackage [ac28244f] is fixed to version 0.1.0\n └─restricted to versions 0.5.9 by an explicit requirement — no versions left\n```\n\nWe get a version compatibility conflict.\nIt is not possible to reconcile the requirement of adding `MacroTools` `0.5.9` with the fact that it is only allowed to reach up to `0.5.8` for `MyPackage`.\n\nCompatibility conflicts are the main reason why you should give each of your projects its own local environment instead of always using the global one.\nFirst of all, you're more and more likely to end up with old versions or compatibility clashes, the more packages you install.\nSecond, if you inadvertently update your main environment for project B, but later go back to project A, it could very well be that the new package versions are now incompatible with the code you wrote for A at the time.\nYou don't want to tangle all your projects up together, so just make separate environments for each.\n\n## Stacked environments\n\nThere's another behavior of environments that is potentially very confusing for beginners, and it's called \"stacked environments\".\nLet's restart Julia again, and add the package `Infiltrator` to the main environment:\n\n```julia\n(@v1.8) pkg> add Infiltrator\n    Updating registry at `~/.julia/registries/General.toml`\n   Resolving package versions...\n   Installed Infiltrator ─ v1.6.1\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [5903a43b] + Infiltrator v1.6.1\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [5903a43b] + Infiltrator v1.6.1\n  [b77e0a4c] + InteractiveUtils\n  [3fa0cd96] + REPL\n  [6462fe0b] + Sockets\n  [cf7118a7] + UUIDs\n  [4ec0a83e] + Unicode\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds. 2 already precompiled.\n```\n\nNow we activate the environment of `MyPackage`:\n\n```julia\n(@v1.8) pkg> activate MyPackage\n  Activating project at `~/MyPackage`\n```\n\nLet's see what happens if we load `Infiltrator`:\n\n```julia\njulia> using Infiltrator\n```\n\nIt worked.\nBut why?\n`Infiltrator` is not available in `MyPackage`'s Project.toml.\n\nThe reason is that Julia can import packages from multiple environments at the same time.\nThis depends on the `LOAD_PATH` global variable.\nLet's have a look:\n\n```julia\njulia> LOAD_PATH\n3-element Vector{String}:\n \"@\"\n \"@v#.#\"\n \"@stdlib\"\n```\n\nThe first entry, `\"@\"`, means \"active environment\", so the first place where Julia looked for Infiltrator was in `MyPackage`'s environment, where it didn't find it.\n\nThe second entry, `\"@v#.#\"` means \"the shared environment of this Julia version\", in our case this is `@v1.8`.\nThat's why I kept calling this the \"main\" environment, not only because it's the default one, but also because it's always available by default due to the `LOAD_PATH` configuration.\nThis is where Julia found `Infiltrator` and loaded it.\n\nThe third entry, `\"@stdlib\"`, refers to the list of standard libraries that belongs to the current Julia version.\nThis is the reason why we can do `using Statistics` or `using REPL` in a new Julia session, even if our main environment is empty.\n\nThe potential confusion comes from the fact that a user can activate a package environment and work there under the assumption that only package dependencies are available.\nThis might hide the fact that some of the included packages are drawn in from the main environment, which will lead to an error later, if the package is installed to a new environment and can't access the dependency anymore.\n\nThe best practice for stacked environments is to use the main environment sparingly.\n`Infiltrator` is a good example for a package to install there, because it's a debugging package and basically never needed as a dependency for another package.\nOn the other hand it's very useful to have available without further work when developing.\nAnother example is `Revise`.\n\nIf you really want to make sure that only the packages from your currently activated project are accessible, you can remove other entries from the load path.\n\nTo demonstrate this, if we empty the load path we can't load any package at all, neither `Infiltrator` from `@v1.8`, nor `MyPackage` from our active environment, nor the standard library `Statistics`:\n\n```julia\njulia> empty!(LOAD_PATH)\nString[]\n\njulia> using Infiltrator\n │ Package Infiltrator not found, but a package named Infiltrator is available from a registry.\n │ Install package?\n │   (MyPackage) pkg> add Infiltrator\n └ (y/n/o) [y]: n\nERROR: ArgumentError: Package Infiltrator not found in current path, maybe you meant `import/using .Infiltrator`.\n\njulia> using MyPackage\nERROR: ArgumentError: Package MyPackage not found in current path.\n- Run `import Pkg; Pkg.add(\"MyPackage\")` to install the MyPackage package.\n\njulia> using Statistics\nERROR: ArgumentError: Package Statistics not found in current path.\n- Run `import Pkg; Pkg.add(\"Statistics\")` to install the Statistics package.\n```\n\n## Temporary environments\n\nOne thing that's useful for quick tests are temporary environments.\nIf you read about a new package and quickly want to try it, but don't want to mess with your main environment or clutter your working directory with environment files, you can use `activate --temp`:\n\n```julia\n(@v1.8) pkg> activate --temp\n  Activating new project at `/var/folders/z5/r5q6djwn5g10k3w279bn37700000gn/T/jl_LM4bTG`\n\n(jl_LM4bTG) pkg>\n```\n\nThis environment will only exist until the Julia process exits, so it's perfect to run something once and then forget about it.\n\n## Conclusion\n\nThis was a short tour of `Pkg` and its main functions.\nI hope it has become more clear how environments work and why you shouldn't rely on a single global one.\nIt's quite easy to make one environment per project and the text files created use effectively no space, so there's no downside to doing this.\n\nFor more info, have a look at some of these sources:\n\n- [Pkg.jl documentation](https://pkgdocs.julialang.org/v1/).\n- [DrWatson.jl](https://juliadynamics.github.io/DrWatson.jl/stable/), a tool that tries to make the process of setting up reproducible projects easier.\n- [TestEnv.jl](https://github.com/JuliaTesting/TestEnv.jl) which helps with the problem of stacked environments in the context of tests (not covered here).\n- [PkgTemplates.jl](https://github.com/invenia/PkgTemplates.jl) which makes creating packages easier.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}