---
title: "Pkg.jl and Julia Environments for Beginners"
date: 2022-08-27
categories: ["julia"]
---

When you start using Julia, you will quickly come in contact with Pkg.jl, its package manager.
It's reasonably easy to install a few packages and start using Julia.
But from reading questions on Slack and Discourse, many users only start understanding relatively late what commands like `instantiate` are doing.
This post should teach you how you can step beyond a messy global environment and towards neatly packaged local versions that allow you to collaborate more effectively and make your results reproducible.

## Getting started

When you install Julia for the first time, there are no environments.
Let's say you installed Julia 1.8.
When you start the REPL with the `julia` command, you will see the standard prompt


```terminal
<span class="sgr-bold sgr-fg-3">julia> </span>
```

From there, you get to the Pkg.jl REPL mode by typing `]`.
The prompt will change to indicate this, by showing the name of the active environment:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span>
```

But wait, didn't I just say there are no environments, yet?
That's true, there shouldn't be any environment files on your computer.
You can check the `.julia/environments` folder, it should be empty.
This folder contains all your "shared" environments.
You can tell that an environment is shared by the leading `@` character in the package REPL prompt, in our case `@v1.8` because we use Julia 1.8.

(Note that if you already have a folder called `v1.8`, or whatever Julia version you're using, you can just rename that to `v1.8_deactivated` or something and restart Julia for the purposes of this tutorial.)

If a new environment is activated, this doesn't yet create any files, and that's why we don't have any files in `.julia/environments`, yet.
They only appear once you actually do something with your environment.

We can test this quickly.
Activate a new environment by typing `(@v1.8) pkg> activate MyEnvironment`.
You won't see any new files being created in your working directory, as I said this only happens once you manipulate an environment.
But the prompt will have changed:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>activate MyEnvironment
</span><span class="sgr-bold sgr-fg-3">  Activating</span><span> new project at `~/MyEnvironment`

</span><span class="sgr-bold sgr-fg-5">(MyEnvironment) pkg> </span>
```

Let's switch back to the "main" environment `@v1.8` for now.

The purpose of shared environments is that you can activate them easily from any working directory because they start with `@`, and Pkg knows to look for them in `.julia/environments`.
For all other environments, you can activate them by name if you are in the directory where they were created, or you have to specify the full path.

So we activate `@v1.8` again by typing:

```terminal
</span><span class="sgr-bold sgr-fg-5">(MyEnvironment) pkg> </span><span>activate @v1.8
</span><span class="sgr-bold sgr-fg-3">  Activating</span><span> new project at `~/.julia/environments/v1.8`

</span><span class="sgr-bold sgr-fg-5">(@v1.8) pkg> 
```

As you see, Pkg told us we were activating a new project (another word for environment), because as we saw before, no files did actually exist, yet.

There's another shortcut to activate the main environment, which is `activate` without an argument:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>activate
</span><span class="sgr-bold sgr-fg-3">  Activating</span><span> new project at `~/.julia/environments/v1.8`

</span><span class="sgr-bold sgr-fg-5">(@v1.8) pkg> 
```

## Adding a package

Let's add our first package to our shared `@v1.8` environment.
For this, we use the `add` command.
I choose the `MacroTools` package because it has few dependencies.

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>add MacroTools
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> registry at `~/.julia/registries/General.toml`
</span><span class="sgr-bold sgr-fg-3">   Resolving</span><span> package versions...
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Project.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b3">+ MacroTools v0.5.9</span><span>
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Manifest.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b3">+ MacroTools v0.5.9</span><span>
 </span><span class="sgr-fg-b1"> [2a0f44e3] </span><span class="sgr-fg-b3">+ Base64</span><span>
 </span><span class="sgr-fg-b1"> [d6f4376e] </span><span class="sgr-fg-b3">+ Markdown</span><span>
 </span><span class="sgr-fg-b1"> [9a3f8284] </span><span class="sgr-fg-b3">+ Random</span><span>
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span class="sgr-fg-b3">+ SHA v0.7.0</span><span>
 </span><span class="sgr-fg-b1"> [9e88b42a] </span><span class="sgr-fg-b3">+ Serialization</span><span>
</span>
```

As you probably know, after doing this, the `MacroTools` code has been downloaded onto your system and you can use it in your own code:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>using MacroTools
```

So what actually happened when we ran the `add` command?

In the first line, you can see that the general registry was updated.
The general registry ([https://github.com/JuliaRegistries/General](https://github.com/JuliaRegistries/General)) is a list of third-party packages that are available to the public, where each package lists all its dependencies and versions.
There can be other registries, even private ones, but the general registry is the main one which will be the only one relevant for most users.

Pkg has first updated this list on our computer when we ran `add MacroTools` so that it knows about the most recent versions of all packages in the ecosystem.
You can have a look at it in `.julia/registries/` if you want.

After updating the registry, Pkg is `Resolving package versions`.
First, `MacroTools` latest version at the time of writing, `v0.5.9`, was added to `~/.julia/environments/v1.8/Project.toml`.
So at this point in time, finally the environment file I was talking about earlier is being created.

We can look at the content of `Project.toml`:

```toml
[deps]
MacroTools = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"
```

So this just says that our environment has one dependency declared, which is `MacroTools.jl`.
The UUID string `1914dd2f-81c6...` is there because that's the "real" unique identifier of the package because, e.g., if another hypothetical registry had a different `MacroTools`, then at least you could specify the one you really want via the UUID.

Pkg also updated the file `~/.julia/environments/v1.8/Manifest.toml`.
Let's have a look at this one:

```toml
# This file is machine-generated - editing it directly is not advised

julia_version = "1.8.0-rc3"
manifest_format = "2.0"
project_hash = "e39ab6d265da4acedccb7411db33219b8d7db4fc"

[[deps.Base64]]
uuid = "2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"

[[deps.MacroTools]]
deps = ["Markdown", "Random"]
git-tree-sha1 = "3d3e902b31198a27340d0bf00d6ac452866021cf"
uuid = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"
version = "0.5.9"

[[deps.Markdown]]
deps = ["Base64"]
uuid = "d6f4376e-aef5-505a-96c1-9c027394607a"

[[deps.Random]]
deps = ["SHA", "Serialization"]
uuid = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"

[[deps.SHA]]
uuid = "ea8e919c-243c-51af-8825-aaa63cd721ce"
version = "0.7.0"

[[deps.Serialization]]
uuid = "9e88b42a-f829-5b0c-bbe9-9e923198166b"
```

The `Manifest.toml` lists all the packages that were actually installed for you, while the `Project.toml` only lists the `MacroTools` dependency.

You can think of the two files this way:

  - `Project.toml`: What you want.
  - `Manifest.toml`: What you get.

The `Project.toml` is always the first file being edited when you make environment changes, if that is through the Pkg REPL or manually.
The `Manifest.toml` is then the result of a computation that tries to find compatible versions of all packages specified in the `Project.toml` and their dependencies.
Note that `Project.toml` can in principle specify impossible demands, like two packages that require incompatible dependencies.
A `Manifest.toml` however should always be in a valid state, if no valid configuration of package dependencies can be resolved, you will just get an error.

We can see the dependency graph that Pkg resolved in the `Manifest.toml`, if we look at the `deps` fields:

```{dot}
digraph G {
  MacroTools -> Markdown
  MacroTools -> Random
  Markdown -> Base64
  Random -> SHA
  Random -> Serialization
  MacroTools [label="MacroTools v0.5.9", style=filled, fillcolor="slategray2"]
  SHA [label="SHA v0.7.0", style=filled, fillcolor="tomato"]
  Markdown [style=filled, fillcolor="tomato"]
  Random [style=filled, fillcolor="tomato"]
  Serialization [style=filled, fillcolor="tomato"]
  Base64 [style=filled, fillcolor="tomato"]
}
```

The blue node refers to the external package `MacroTools`, which has a version.
The red nodes are standard libraries.
Standard libraries are shipped with Julia, so they usually don't have their own version and only change with each Julia release.
You can look at the all the standard libraries in the [Julia repository on GitHub](https://github.com/JuliaLang/julia/tree/master/stdlib).
Standard libraries can depend on other standard libraries.
SHA is an unusual standard library because it's hosted externally and has a version.
But the version is still fixed for each Julia version via a `.version` file such as [the one for SHA](https://github.com/JuliaLang/julia/blob/master/stdlib/SHA.version), so most users can just treat it like a normal standard library.
In this example, MacroTools depends only on standard libraries, but most other packages depend on other external packages as well.

You can check the versions of libraries in your `Project.toml` and `Manifest.toml` with the `status` or `st` command.
With the `-m` flag you can see the `Manifest.toml` entries, which can be important for checking which dependencies were resolved.

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>st
</span><span class="sgr-bold sgr-fg-3">Status</span><span> `~/.julia/environments/v1.8/Project.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span>MacroTools v0.5.9

</span><span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>st -m
</span><span class="sgr-bold sgr-fg-3">Status</span><span> `~/.julia/environments/v1.8/Manifest.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span>MacroTools v0.5.9
 </span><span class="sgr-fg-b1"> [2a0f44e3] </span><span>Base64
 </span><span class="sgr-fg-b1"> [d6f4376e] </span><span>Markdown
 </span><span class="sgr-fg-b1"> [9a3f8284] </span><span>Random
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span>SHA v0.7.0
 </span><span class="sgr-fg-b1"> [9e88b42a] </span><span>Serialization

</span><span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>st -m SHA
</span><span class="sgr-bold sgr-fg-3">Status</span><span> `~/.julia/environments/v1.8/Manifest.toml`
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span>SHA v0.7.0
</span>
```

## Version numbers

To understand how dependencies are resolved, you have to understand [SemVer versioning](https://semver.org).
SemVer stands for semantic versioning, which just means that version numbers should be meaningful, not just random labels.
The three parts of the version number are `major`.`minor`.`patch`.
In Julia, all newer versions with the same major version should have compatible public APIs, so code that works with `v1.2.3` should also work with `v1.20.5`.
The exception is major version `0`, where each new minor version can be considered potentially breaking.
So code that works with `v0.2.4` should still work with `v0.2.13` but not necessarily with `v0.3.0`.
This is because package developers want to be able to make breaking changes even if they haven't brought their package to `v1.0` yet, a version that usually carries the implication of public API stability and is often reached only after the package has been around for a while.

## Adding specific variants of a package

So far, we have only used the command `add MacroTools`, which pulled the latest version `v0.5.9` into our environment.
Sometimes, however, you want a specific variant of a package.
That doesn't necessarily have to be a specific version.
It can also be a commit or branch of a certain repository.
Let's try this out with `MacroTools`.

We can install the version `v0.5.1` by using the `@` syntax:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>add MacroTools@0.5.1
</span><span class="sgr-bold sgr-fg-3">   Resolving</span><span> package versions...
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Project.toml`
</span><span class="sgr-fg-3">⌃</span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b6">↓ MacroTools v0.5.9 ⇒ v0.5.1</span><span>
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Manifest.toml`
</span><span class="sgr-fg-4">⌅</span><span class="sgr-fg-b1"> [00ebfdb7] </span><span class="sgr-fg-b3">+ CSTParser v2.5.0</span><span>
</span><span class="sgr-fg-4">⌅</span><span class="sgr-fg-b1"> [34da2185] </span><span class="sgr-fg-b3">+ Compat v2.2.1</span><span>
</span><span class="sgr-fg-4">⌅</span><span class="sgr-fg-b1"> [864edb3b] </span><span class="sgr-fg-b3">+ DataStructures v0.17.20</span><span>
</span><span class="sgr-fg-3">⌃</span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b6">↓ MacroTools v0.5.9 ⇒ v0.5.1</span><span>
 </span><span class="sgr-fg-b1"> [bac558e1] </span><span class="sgr-fg-b3">+ OrderedCollections v1.4.1</span><span>
 </span><span class="sgr-fg-b1"> [0796e94c] </span><span class="sgr-fg-b3">+ Tokenize v0.5.24</span><span>
 </span><span class="sgr-fg-b1"> [0dad84c5] </span><span class="sgr-fg-b3">+ ArgTools v1.1.1</span><span>
 </span><span class="sgr-fg-b1"> [56f22d72] </span><span class="sgr-fg-b3">+ Artifacts</span><span>
 </span><span class="sgr-fg-b1"> [ade2ca70] </span><span class="sgr-fg-b3">+ Dates</span><span>
 </span><span class="sgr-fg-b1"> [8bb1440f] </span><span class="sgr-fg-b3">+ DelimitedFiles</span><span>
 </span><span class="sgr-fg-b1"> [8ba89e20] </span><span class="sgr-fg-b3">+ Distributed</span><span>
 </span><span class="sgr-fg-b1"> [f43a241f] </span><span class="sgr-fg-b3">+ Downloads v1.6.0</span><span>
 </span><span class="sgr-fg-b1"> [7b1f6079] </span><span class="sgr-fg-b3">+ FileWatching</span><span>
 </span><span class="sgr-fg-b1"> [b77e0a4c] </span><span class="sgr-fg-b3">+ InteractiveUtils</span><span>
 </span><span class="sgr-fg-b1"> [b27032c2] </span><span class="sgr-fg-b3">+ LibCURL v0.6.3</span><span>
 </span><span class="sgr-fg-b1"> [76f85450] </span><span class="sgr-fg-b3">+ LibGit2</span><span>
 </span><span class="sgr-fg-b1"> [8f399da3] </span><span class="sgr-fg-b3">+ Libdl</span><span>
 </span><span class="sgr-fg-b1"> [37e2e46d] </span><span class="sgr-fg-b3">+ LinearAlgebra</span><span>
 </span><span class="sgr-fg-b1"> [56ddb016] </span><span class="sgr-fg-b3">+ Logging</span><span>
 </span><span class="sgr-fg-b1"> [a63ad114] </span><span class="sgr-fg-b3">+ Mmap</span><span>
 </span><span class="sgr-fg-b1"> [ca575930] </span><span class="sgr-fg-b3">+ NetworkOptions v1.2.0</span><span>
 </span><span class="sgr-fg-b1"> [44cfe95a] </span><span class="sgr-fg-b3">+ Pkg v1.8.0</span><span>
 </span><span class="sgr-fg-b1"> [de0858da] </span><span class="sgr-fg-b3">+ Printf</span><span>
 </span><span class="sgr-fg-b1"> [3fa0cd96] </span><span class="sgr-fg-b3">+ REPL</span><span>
 </span><span class="sgr-fg-b1"> [1a1011a3] </span><span class="sgr-fg-b3">+ SharedArrays</span><span>
 </span><span class="sgr-fg-b1"> [6462fe0b] </span><span class="sgr-fg-b3">+ Sockets</span><span>
 </span><span class="sgr-fg-b1"> [2f01184e] </span><span class="sgr-fg-b3">+ SparseArrays</span><span>
 </span><span class="sgr-fg-b1"> [10745b16] </span><span class="sgr-fg-b3">+ Statistics</span><span>
 </span><span class="sgr-fg-b1"> [fa267f1f] </span><span class="sgr-fg-b3">+ TOML v1.0.0</span><span>
 </span><span class="sgr-fg-b1"> [a4e569a6] </span><span class="sgr-fg-b3">+ Tar v1.10.0</span><span>
 </span><span class="sgr-fg-b1"> [8dfed614] </span><span class="sgr-fg-b3">+ Test</span><span>
 </span><span class="sgr-fg-b1"> [cf7118a7] </span><span class="sgr-fg-b3">+ UUIDs</span><span>
 </span><span class="sgr-fg-b1"> [4ec0a83e] </span><span class="sgr-fg-b3">+ Unicode</span><span>
 </span><span class="sgr-fg-b1"> [e66e0078] </span><span class="sgr-fg-b3">+ CompilerSupportLibraries_jll v0.5.2+0</span><span>
 </span><span class="sgr-fg-b1"> [deac9b47] </span><span class="sgr-fg-b3">+ LibCURL_jll v7.83.1+1</span><span>
 </span><span class="sgr-fg-b1"> [29816b5a] </span><span class="sgr-fg-b3">+ LibSSH2_jll v1.10.2+0</span><span>
 </span><span class="sgr-fg-b1"> [c8ffd9c3] </span><span class="sgr-fg-b3">+ MbedTLS_jll v2.28.0+0</span><span>
 </span><span class="sgr-fg-b1"> [14a3606d] </span><span class="sgr-fg-b3">+ MozillaCACerts_jll v2022.2.1</span><span>
 </span><span class="sgr-fg-b1"> [4536629a] </span><span class="sgr-fg-b3">+ OpenBLAS_jll v0.3.20+0</span><span>
 </span><span class="sgr-fg-b1"> [83775a58] </span><span class="sgr-fg-b3">+ Zlib_jll v1.2.12+3</span><span>
 </span><span class="sgr-fg-b1"> [8e850b90] </span><span class="sgr-fg-b3">+ libblastrampoline_jll v5.1.1+0</span><span>
 </span><span class="sgr-fg-b1"> [8e850ede] </span><span class="sgr-fg-b3">+ nghttp2_jll v1.47.0+0</span><span>
 </span><span class="sgr-fg-b1"> [3f19e933] </span><span class="sgr-fg-b3">+ p7zip_jll v17.4.0+0</span><span>
</span><span class="sgr-bold sgr-fg-7">        Info</span><span> Packages marked with </span><span class="sgr-fg-3">⌃</span><span> and </span><span class="sgr-fg-4">⌅</span><span> have new versions available, but those with </span><span class="sgr-fg-4">⌅</span><span> cannot be upgraded. To see why use `status --outdated -m`
</span>
```

You can see that we got a ton of new dependencies.
This happened because `MacroTools` managed to cut the number of packages it depends on a lot over time, so the older version pulls in much more.

If we take a look at the new `Manifest.toml` entry for `MacroTools`, we see:

```toml
[[deps.MacroTools]]
deps = ["CSTParser", "Compat", "DataStructures", "Test", "Tokenize"]
git-tree-sha1 = "d6e9dedb8c92c3465575442da456aec15a89ff76"
uuid = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"
version = "0.5.1"
```

This just goes to show that even between patch versions of a package, which should all follow the same public API, the dependencies can change a lot.

If you look at the `Project.toml`, you will see that it hasn't changed.
The version requirement was just enforced during this one dependency resolution, and won't be remembered or enforced again in future Pkg operations.

Let's try one other syntax, which is the one for choosing a specific commit or branch from a repository.
In this case, we use the commit `639d1a6`, but we could also use something like `master` to fetch the latest commit on that branch.

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>add MacroTools#639d1a6
</span><span class="sgr-bold sgr-fg-3">   Resolving</span><span> package versions...
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Project.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b4">~ MacroTools v0.5.1 ⇒ v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`</span><span>
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Manifest.toml`
 </span><span class="sgr-fg-b1"> [00ebfdb7] </span><span class="sgr-fg-b2">- CSTParser v2.5.0</span><span>
 </span><span class="sgr-fg-b1"> [34da2185] </span><span class="sgr-fg-b2">- Compat v2.2.1</span><span>
 </span><span class="sgr-fg-b1"> [864edb3b] </span><span class="sgr-fg-b2">- DataStructures v0.17.20</span><span>
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b4">~ MacroTools v0.5.1 ⇒ v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`</span><span>
 </span><span class="sgr-fg-b1"> [bac558e1] </span><span class="sgr-fg-b2">- OrderedCollections v1.4.1</span><span>
 </span><span class="sgr-fg-b1"> [0796e94c] </span><span class="sgr-fg-b2">- Tokenize v0.5.24</span><span>
 </span><span class="sgr-fg-b1"> [0dad84c5] </span><span class="sgr-fg-b2">- ArgTools v1.1.1</span><span>
 </span><span class="sgr-fg-b1"> [56f22d72] </span><span class="sgr-fg-b2">- Artifacts</span><span>
 </span><span class="sgr-fg-b1"> [ade2ca70] </span><span class="sgr-fg-b2">- Dates</span><span>
 </span><span class="sgr-fg-b1"> [8bb1440f] </span><span class="sgr-fg-b2">- DelimitedFiles</span><span>
 </span><span class="sgr-fg-b1"> [8ba89e20] </span><span class="sgr-fg-b2">- Distributed</span><span>
 </span><span class="sgr-fg-b1"> [f43a241f] </span><span class="sgr-fg-b2">- Downloads v1.6.0</span><span>
 </span><span class="sgr-fg-b1"> [7b1f6079] </span><span class="sgr-fg-b2">- FileWatching</span><span>
 </span><span class="sgr-fg-b1"> [b77e0a4c] </span><span class="sgr-fg-b2">- InteractiveUtils</span><span>
 </span><span class="sgr-fg-b1"> [b27032c2] </span><span class="sgr-fg-b2">- LibCURL v0.6.3</span><span>
 </span><span class="sgr-fg-b1"> [76f85450] </span><span class="sgr-fg-b2">- LibGit2</span><span>
 </span><span class="sgr-fg-b1"> [8f399da3] </span><span class="sgr-fg-b2">- Libdl</span><span>
 </span><span class="sgr-fg-b1"> [37e2e46d] </span><span class="sgr-fg-b2">- LinearAlgebra</span><span>
 </span><span class="sgr-fg-b1"> [56ddb016] </span><span class="sgr-fg-b2">- Logging</span><span>
 </span><span class="sgr-fg-b1"> [a63ad114] </span><span class="sgr-fg-b2">- Mmap</span><span>
 </span><span class="sgr-fg-b1"> [ca575930] </span><span class="sgr-fg-b2">- NetworkOptions v1.2.0</span><span>
 </span><span class="sgr-fg-b1"> [44cfe95a] </span><span class="sgr-fg-b2">- Pkg v1.8.0</span><span>
 </span><span class="sgr-fg-b1"> [de0858da] </span><span class="sgr-fg-b2">- Printf</span><span>
 </span><span class="sgr-fg-b1"> [3fa0cd96] </span><span class="sgr-fg-b2">- REPL</span><span>
 </span><span class="sgr-fg-b1"> [1a1011a3] </span><span class="sgr-fg-b2">- SharedArrays</span><span>
 </span><span class="sgr-fg-b1"> [6462fe0b] </span><span class="sgr-fg-b2">- Sockets</span><span>
 </span><span class="sgr-fg-b1"> [2f01184e] </span><span class="sgr-fg-b2">- SparseArrays</span><span>
 </span><span class="sgr-fg-b1"> [10745b16] </span><span class="sgr-fg-b2">- Statistics</span><span>
 </span><span class="sgr-fg-b1"> [fa267f1f] </span><span class="sgr-fg-b2">- TOML v1.0.0</span><span>
 </span><span class="sgr-fg-b1"> [a4e569a6] </span><span class="sgr-fg-b2">- Tar v1.10.0</span><span>
 </span><span class="sgr-fg-b1"> [8dfed614] </span><span class="sgr-fg-b2">- Test</span><span>
 </span><span class="sgr-fg-b1"> [cf7118a7] </span><span class="sgr-fg-b2">- UUIDs</span><span>
 </span><span class="sgr-fg-b1"> [4ec0a83e] </span><span class="sgr-fg-b2">- Unicode</span><span>
 </span><span class="sgr-fg-b1"> [e66e0078] </span><span class="sgr-fg-b2">- CompilerSupportLibraries_jll v0.5.2+0</span><span>
 </span><span class="sgr-fg-b1"> [deac9b47] </span><span class="sgr-fg-b2">- LibCURL_jll v7.83.1+1</span><span>
 </span><span class="sgr-fg-b1"> [29816b5a] </span><span class="sgr-fg-b2">- LibSSH2_jll v1.10.2+0</span><span>
 </span><span class="sgr-fg-b1"> [c8ffd9c3] </span><span class="sgr-fg-b2">- MbedTLS_jll v2.28.0+0</span><span>
 </span><span class="sgr-fg-b1"> [14a3606d] </span><span class="sgr-fg-b2">- MozillaCACerts_jll v2022.2.1</span><span>
 </span><span class="sgr-fg-b1"> [4536629a] </span><span class="sgr-fg-b2">- OpenBLAS_jll v0.3.20+0</span><span>
 </span><span class="sgr-fg-b1"> [83775a58] </span><span class="sgr-fg-b2">- Zlib_jll v1.2.12+3</span><span>
 </span><span class="sgr-fg-b1"> [8e850b90] </span><span class="sgr-fg-b2">- libblastrampoline_jll v5.1.1+0</span><span>
 </span><span class="sgr-fg-b1"> [8e850ede] </span><span class="sgr-fg-b2">- nghttp2_jll v1.47.0+0</span><span>
 </span><span class="sgr-fg-b1"> [3f19e933] </span><span class="sgr-fg-b2">- p7zip_jll v17.4.0+0</span>
```

Note that even though the version printed for MacroTools is again `0.5.9`, this doesn't necessarily mean that we are on the same commit as the one pointed to by the version `0.5.9` in the registry.
It just means that Pkg cloned the repository, checked out the commit with hash `639d1a6` and found the version specifier `0.5.9` in MacroTools's own `Project.toml` file.
Therefore, infinitely many code versions of a package can be treated as version `X.Y.Z` by Pkg, but `X.Y.Z` itself refers only to exactly one version.
This distinction is important to remember when developing and editing a package, but more about that later.

If we take another look at our `Manifest.toml`, we can see the following entry for MacroTools:

```toml
[[deps.MacroTools]]
deps = ["Markdown", "Random"]
git-tree-sha1 = "465a4803356bcb11f6eb97df992680f13a9ba776"
repo-rev = "639d1a6"
repo-url = "https://github.com/FluxML/MacroTools.jl.git"
uuid = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"
version = "0.5.9"
```

This time, the URL of the repository was recorded, as well as the revision, which was `639d1a6`.
This is because as soon as you specify a revision in the `add` command, Pkg knows you're operating outside of the registry, so it cannot rely on the repository information stored there for MacroTools.

(Note that you can also install unregistered packages, or forks of registered packages this way, by doing `add https://the_url_to_the_git_repository`.)

The manifest needs to store the url and revision in order to make the project reproducible by someone else.
Let's actually look at what reproducing an environment looks like:

## Reproducing an environment

Let's say you have written some code relying on the specific `MacroTools` version we added via `add MacroTools#639d1a6` and want your colleague to be able to run that code with the exact packages installed that we used at the time.

Which files do they need to reproduce the state of your environment?
Not just the `Project.toml`, because remember, it still only contains this information:

```julia
[deps]
MacroTools = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"
```

We need to also send the `Manifest.toml` because it records the exact versions of all packages.
Let's pretend we are our colleague, and we just received a `Project.toml` and `Manifest.toml` file.
How do we actually get the environment installed?

Let's copy the files into a new folder we call `ColleagueEnv` in our current working directory.

To pretend we're the colleague who just uses Julia for the first time, we also delete the `.julia/packages/MacroTools` folder in which the downloaded source code of `MacroTools` was stored.

Note that this means that the source code is not part of an environment but stored centrally.
It would be pretty wasteful to download the same sources over and over just because you're using different local environments.

Let's now restart Julia and activate the `ColleagueEnv` environment:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>activate ./ColleagueEnv
</span><span class="sgr-bold sgr-fg-3">  Activating</span><span> project at `~/ColleagueEnv`
</span>
```

We can check the installed packages via `st -m`:

```terminal
<span class="sgr-bold sgr-fg-5">(ColleagueEnv) pkg> </span><span>st -m
</span><span class="sgr-bold sgr-fg-3">Status</span><span> `~/ColleagueEnv/Manifest.toml`
</span><span class="sgr-fg-b2">→</span><span class="sgr-fg-b1"> [1914dd2f] </span><span>MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#master`
 </span><span class="sgr-fg-b1"> [2a0f44e3] </span><span>Base64
 </span><span class="sgr-fg-b1"> [d6f4376e] </span><span>Markdown
 </span><span class="sgr-fg-b1"> [9a3f8284] </span><span>Random
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span>SHA v0.7.0
 </span><span class="sgr-fg-b1"> [9e88b42a] </span><span>Serialization
</span><span class="sgr-bold sgr-fg-7">Info</span><span> Packages marked with </span><span class="sgr-fg-b2">→</span><span> are not downloaded, use `instantiate` to download
</span>
```

If we were trying to just run some code using `MacroTools` now, this would happen:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>using MacroTools
</span><span class="sgr-bold sgr-fg-b2">ERROR: </span><span>ArgumentError: Package MacroTools [1914dd2f-81c6-5fcd-8719-6d5c9610ff09] is required but does not seem to be installed:
 - Run `Pkg.instantiate()` to install all recorded dependencies.

Stacktrace:
 [1] </span><span class="sgr-bold">_require(</span><span class="sgr-fg-b1">pkg</span><span>::Base.PkgId</span><span class="sgr-bold">)</span><span>
</span><span class="sgr-fg-b1">   @ Base</span><span> </span><span class="sgr-fg-b1">./loading.jl:1306</span><span>
 [2] </span><span class="sgr-bold">_require_prelocked(</span><span class="sgr-fg-b1">uuidkey</span><span>::Base.PkgId</span><span class="sgr-bold">)</span><span>
</span><span class="sgr-fg-b1">   @ Base</span><span> </span><span class="sgr-fg-b1">./loading.jl:1200</span><span>
 [3] </span><span class="sgr-bold">macro expansion</span><span>
</span><span class="sgr-fg-b1">   @ ./loading.jl:1180 [inlined]</span><span>
 [4] </span><span class="sgr-bold">macro expansion</span><span>
</span><span class="sgr-fg-b1">   @ ./lock.jl:223 [inlined]</span><span>
 [5] </span><span class="sgr-bold">require(</span><span class="sgr-fg-b1">into</span><span>::Module, </span><span class="sgr-fg-b1">mod</span><span>::Symbol</span><span class="sgr-bold">)</span><span>
</span><span class="sgr-fg-b1">   @ Base</span><span> </span><span class="sgr-fg-b1">./loading.jl:1144</span>
```

So we need to follow the advice already printed twice for us, and call `instantiate`.
This will download everything specified in the `Manifest.toml` exactly as it was recorded there.
You can actually be sure that it's exactly the same because the `Manifest.toml` stores git tree hashes of each dependency.
Unless someone deletes these specific parts of the repository you will be able to download the source exactly as it was:

```terminal
<span class="sgr-bold sgr-fg-5">(ColleagueEnv) pkg> </span><span>instantiate
</span><span class="sgr-bold sgr-fg-3">Precompiling</span><span> project...
</span><span class="sgr-fg-3">  ✓ </span><span>MacroTools
  1 dependency successfully precompiled in 1 seconds

</span><span class="sgr-bold sgr-fg-5">(ColleagueEnv) pkg> </span><span>st -m
</span><span class="sgr-bold sgr-fg-3">Status</span><span> `~/ColleagueEnv/Manifest.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span>MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#master`
 </span><span class="sgr-fg-b1"> [2a0f44e3] </span><span>Base64
 </span><span class="sgr-fg-b1"> [d6f4376e] </span><span>Markdown
 </span><span class="sgr-fg-b1"> [9a3f8284] </span><span>Random
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span>SHA v0.7.0
 </span><span class="sgr-fg-b1"> [9e88b42a] </span><span>Serialization
</span>
```

Now we don't get a warning anymore, our dependencies have been downloaded correctly.
You will find `MacroTools` downloaded into the `.julia/packages` folder again.

## Packages and environments

Packages and normal environments are pretty similar.
Each package must have a `Project.toml` which specifies its name, UUID, version and dependencies.
The easiest way to make a package to test this out, is to use the `generate` command of the Pkg REPL.

Let's restart Julia and remove `MacroTools` from our main environment so it is empty:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>rm MacroTools
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Project.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b2">- MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`</span><span>
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Manifest.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b2">- MacroTools v0.5.9 `https://github.com/FluxML/MacroTools.jl.git#639d1a6`</span><span>
 </span><span class="sgr-fg-b1"> [2a0f44e3] </span><span class="sgr-fg-b2">- Base64</span><span>
 </span><span class="sgr-fg-b1"> [d6f4376e] </span><span class="sgr-fg-b2">- Markdown</span><span>
 </span><span class="sgr-fg-b1"> [9a3f8284] </span><span class="sgr-fg-b2">- Random</span><span>
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span class="sgr-fg-b2">- SHA v0.7.0</span><span>
 </span><span class="sgr-fg-b1"> [9e88b42a] </span><span class="sgr-fg-b2">- Serialization</span>
```

Now, we generate a new package called `MyPackage`:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>generate MyPackage
</span><span class="sgr-bold sgr-fg-3">  Generating</span><span>  project MyPackage:
    MyPackage/Project.toml
    MyPackage/src/MyPackage.jl
</span>
```

As you can see, a `Project.toml` file was generated in the `MyPackage` directory.

Let's have a look at this one:

```toml
name = "MyPackage"
uuid = "025f59cc-7e1c-467d-8f56-70157e1cbbbb"
authors = ["Your Name <your@email.com>"]
version = "0.1.0"
```

The only difference from a basic package environment to a normal environment are those four fields.
If we want to use `MacroTools` in our package, we can add it manually to a `deps` section in the `Project.toml`, or we use the Pkg REPL.
For that, we first activate the package as an environment, then we add `MacroTools`.

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>activate MyPackage/
</span><span class="sgr-bold sgr-fg-3">  Activating</span><span> project at `~/MyPackage`

</span><span class="sgr-bold sgr-fg-5">(MyPackage) pkg> </span><span>add MacroTools
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> registry at `~/.julia/registries/General.toml`
</span><span class="sgr-bold sgr-fg-3">   Resolving</span><span> package versions...
</span><span class="sgr-bold sgr-fg-3">   Installed</span><span> MacroTools ─ v0.5.9
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/MyPackage/Project.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b3">+ MacroTools v0.5.9</span><span>
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/MyPackage/Manifest.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b3">+ MacroTools v0.5.9</span><span>
 </span><span class="sgr-fg-b1"> [2a0f44e3] </span><span class="sgr-fg-b3">+ Base64</span><span>
 </span><span class="sgr-fg-b1"> [d6f4376e] </span><span class="sgr-fg-b3">+ Markdown</span><span>
 </span><span class="sgr-fg-b1"> [9a3f8284] </span><span class="sgr-fg-b3">+ Random</span><span>
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span class="sgr-fg-b3">+ SHA v0.7.0</span><span>
 </span><span class="sgr-fg-b1"> [9e88b42a] </span><span class="sgr-fg-b3">+ Serialization</span><span>
</span><span class="sgr-bold sgr-fg-3">Precompiling</span><span> project...
</span><span class="sgr-fg-3">  ✓ </span><span>MacroTools
</span><span class="sgr-fg-3">  ✓ </span><span>MyPackage
  2 dependencies successfully precompiled in 1 seconds
</span>
```

The `Project.toml` now looks like this:

```toml
name = "MyPackage"
uuid = "025f59cc-7e1c-467d-8f56-70157e1cbbbb"
authors = ["Your Name <your@email.com>"]
version = "0.1.0"

[deps]
MacroTools = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"
```

In the file `MyPackage/src/MyPackage.jl`, we can now import `MacroTools` and work with it.
Let's change the content of that file to:

```julia
module MyPackage

import MacroTools

function test()
    MacroTools.@capture :(1 + 2) x_ + y_
    @show x
    @show y
    return
end

end # module MyPackage
```

We can now `import` or `using` our package and verify that `MacroTools` can be used by its source code:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>using MyPackage

</span><span class="sgr-bold sgr-fg-3">julia> </span><span>MyPackage.test()
x = 1
y = 2
</span>
```

That worked!

## The `develop` command

Let's restart Julia now, which will bring us back to the main environment.
Let's try again to import our package:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>using MyPackage
</span><span class="sgr-bold sgr-fg-b2">ERROR: </span><span>ArgumentError: Package MyPackage not found in current path.
- Run `import Pkg; Pkg.add("MyPackage")` to install the MyPackage package.
Stacktrace:
 [1] </span><span class="sgr-bold">macro expansion</span><span>
</span><span class="sgr-fg-b1">   @ ./loading.jl:1163 [inlined]</span><span>
 [2] </span><span class="sgr-bold">macro expansion</span><span>
</span><span class="sgr-fg-b1">   @ ./lock.jl:223 [inlined]</span><span>
 [3] </span><span class="sgr-bold">require(</span><span class="sgr-fg-b1">into</span><span>::Module, </span><span class="sgr-fg-b1">mod</span><span>::Symbol</span><span class="sgr-bold">)</span><span>
</span><span class="sgr-fg-b1">   @ Base</span><span> </span><span class="sgr-fg-b1">./loading.jl:1144</span><span>
</span>
```

This doesn't work, because our main environment doesn't have `MyPackage` installed.
You can use `MyPackage` as long as you have its own environment activated, but outside of that it is not visible.

We can change that by using the `develop` or `dev` command of the Pkg REPL, which will install and track `MyPackage`:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>dev ./MyPackage/
</span><span class="sgr-bold sgr-fg-3">   Resolving</span><span> package versions...
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Project.toml`
 </span><span class="sgr-fg-b1"> [025f59cc] </span><span class="sgr-fg-b3">+ MyPackage v0.1.0 `../../../MyPackage`</span><span>
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Manifest.toml`
 </span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b3">+ MacroTools v0.5.9</span><span>
 </span><span class="sgr-fg-b1"> [025f59cc] </span><span class="sgr-fg-b3">+ MyPackage v0.1.0 `../../../MyPackage`</span><span>
 </span><span class="sgr-fg-b1"> [2a0f44e3] </span><span class="sgr-fg-b3">+ Base64</span><span>
 </span><span class="sgr-fg-b1"> [d6f4376e] </span><span class="sgr-fg-b3">+ Markdown</span><span>
 </span><span class="sgr-fg-b1"> [9a3f8284] </span><span class="sgr-fg-b3">+ Random</span><span>
 </span><span class="sgr-fg-b1"> [ea8e919c] </span><span class="sgr-fg-b3">+ SHA v0.7.0</span><span>
 </span><span class="sgr-fg-b1"> [9e88b42a] </span><span class="sgr-fg-b3">+ Serialization</span><span>
</span>
```

Great, that worked.
Now we can access `MyPackage` again:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>using MyPackage
</span><span class="sgr-bold sgr-fg-7">[ Info: </span><span>Precompiling MyPackage [025f59cc-7e1c-467d-8f56-70157e1cbbbb]

</span><span class="sgr-bold sgr-fg-3">julia> </span><span>MyPackage.test()
x = 1
y = 2
</span>
```

Why would we want to do this, use a separate environment to access our package environment?
It's because we probably want to use other packages that should not be dependencies of `MyPackage` while developing it.
For example, a data analysis package could be developed while using a package like [RDatasets.jl](https://github.com/JuliaStats/RDatasets.jl) which supplies test datasets.

## Compatibility bounds

Currently, `MyPackage` does not specify the versions of `MacroTools` with which it is compatible.
That is usually not a good idea, in fact, the general registry doesn't allow packages to be registered if they don't specify upper compatibility boundaries for each dependency.
That makes sense because you don't know if your package will be compatible with all future versions of your dependencies, so it makes sense to cap the compatibility to the point where you have tested everything works.

Let's pretend we tested our package only up to `MacroTools` version `0.5.8`.
We can write this requirement into the `Project.toml` of `MyPackage`:

```toml
name = "MyPackage"
uuid = "025f59cc-7e1c-467d-8f56-70157e1cbbbb"
authors = ["Your Name <your@email.com>"]
version = "0.1.0"

[deps]
MacroTools = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"

[compat]
MacroTools = "<0.5.9"
```

But this change is not picked up automatically by the `@v1.8` environment.
To recompute the dependency graph and throw away the old `Manifest.toml`, we can run `update` or `up`:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>up
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> registry at `~/.julia/registries/General.toml`
</span><span class="sgr-bold sgr-fg-3">   Installed</span><span> MacroTools ─ v0.5.8
</span><span class="sgr-bold sgr-fg-3">  No Changes</span><span> to `~/.julia/environments/v1.8/Project.toml`
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Manifest.toml`
</span><span class="sgr-fg-3">⌃</span><span class="sgr-fg-b1"> [1914dd2f] </span><span class="sgr-fg-b6">↓ MacroTools v0.5.9 ⇒ v0.5.8</span><span>
</span><span class="sgr-bold sgr-fg-7">        Info</span><span> Packages marked with </span><span class="sgr-fg-3">⌃</span><span> have new versions available
</span><span class="sgr-bold sgr-fg-3">Precompiling</span><span> project...
</span><span class="sgr-fg-4">  ✓ </span><span class="sgr-fg-b1">MacroTools</span><span>
</span><span class="sgr-fg-4">  ✓ </span><span>MyPackage
  2 dependencies successfully precompiled in 2 seconds
  </span>
```

As you can see, the MacroTools package was correctly downgraded to `v0.5.8`.

What would happen if we now tried to install `v0.5.9` into the main environment?

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>add MacroTools@0.5.9
</span><span class="sgr-bold sgr-fg-3">   Resolving</span><span> package versions...
</span><span class="sgr-bold sgr-fg-b2">ERROR: </span><span>Unsatisfiable requirements detected for package MacroTools [1914dd2f]:
 MacroTools [1914dd2f] log:
 ├─possible versions are: 0.4.3-0.5.9 or uninstalled
 ├─restricted to versions 0.0.0-0.5.8 by MyPackage [025f59cc], leaving only versions 0.4.3-0.5.8
 │ └─MyPackage [025f59cc] log:
 │   ├─possible versions are: 0.1.0 or uninstalled
 │   └─MyPackage [025f59cc] is fixed to version 0.1.0
 └─restricted to versions 0.5.9 by an explicit requirement — no versions left
</span>
```

We get a version compatibility conflict.
It is not possible to reconcile the requirement of adding `MacroTools` `0.5.9` with the fact that it is only allowed to reach up to `0.5.8` for `MyPackage`.

Compatibility conflicts are the main reason why you should give each of your projects its own local environment instead of always using the global one.
First of all, you're more and more likely to end up with old versions or compatibility clashes, the more packages you install.
Second, if you inadvertently update your main environment for project B, but later go back to project A, it could very well be that the new package versions are now incompatible with the code you wrote for A at the time.
You don't want to tangle all your projects up together, so just make separate environments for each.

## Differences between `add` and `develop`

In our examples, we have seen the `add` and `develop` commands when dealing with packages we want to install.

Both `add` and `dev` can be used to include packages in your environment.
Both can take a local path, or the name of a registered package, or a link to a repository as sources.
So why do we have two separate but similar commands?

The difference is that `add` treats packages as fixed, read-only resources.
When you `add` a package, no matter if local or remote, each version is copied to an internal Julia folder where it should not be modified anymore.

When you `dev` a local package, it stays where it is and can be modified by you.
You just have to remember to restart Julia to load any changes you make (unless they can be auto-reloaded by [Revise.jl](https://github.com/timholy/Revise.jl), which you should check out if you haven't seen it yet), and to `update` the environment in case you make changes to the `Project.toml` like new dependencies or compatibility bounds.
When you use `dev`, Julia is said to "track" that package.

Because you're expected to make changes to code when you use `dev`, Julia copies packages that you `develop` for the first time by specifying its name or URL (for example `dev MacroTools` or `dev https://github.com/FluxML/MacroTools.jl`) into a special folder at `.julia/dev`.
Here, you can access them with your editor of choice, make changes, and sync those back to GitHub or other version control systems.

Note that if you `dev MacroTools` in one local environment, and later `dev MacroTools` in a different environment, Julia will by default re-use the same repository at `.julia/dev`.
If the first environment was already quite old and you haven't pulled the new changes in a while, you'll probably be surprised that you get that old version when you run `dev` in the fresh environment!
Therefore, it can make sense to use separate local copies of packages you want to work on, if you anticipate that you will work on them in several different contexts.
To do this, you can either clone a repository into a local folder, for example with `git clone https://github.com/FluxML/MacroTools.jl` and then run `dev the_local_folder`.
The other option is running `dev --local MacroTools`, which copies the developed package into the working directory, not `.julia/dev`.

## Stacked environments

There's another behavior of environments that is potentially very confusing for beginners, and it's called "stacked environments".
Let's restart Julia again, and add the package `Infiltrator` to the main environment:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>add Infiltrator
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> registry at `~/.julia/registries/General.toml`
</span><span class="sgr-bold sgr-fg-3">   Resolving</span><span> package versions...
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Project.toml`
 </span><span class="sgr-fg-b1"> [5903a43b] </span><span class="sgr-fg-b3">+ Infiltrator v1.6.1</span><span>
</span><span class="sgr-bold sgr-fg-3">    Updating</span><span> `~/.julia/environments/v1.8/Manifest.toml`
 </span><span class="sgr-fg-b1"> [5903a43b] </span><span class="sgr-fg-b3">+ Infiltrator v1.6.1</span><span>
 </span><span class="sgr-fg-b1"> [b77e0a4c] </span><span class="sgr-fg-b3">+ InteractiveUtils</span><span>
 </span><span class="sgr-fg-b1"> [3fa0cd96] </span><span class="sgr-fg-b3">+ REPL</span><span>
 </span><span class="sgr-fg-b1"> [6462fe0b] </span><span class="sgr-fg-b3">+ Sockets</span><span>
 </span><span class="sgr-fg-b1"> [cf7118a7] </span><span class="sgr-fg-b3">+ UUIDs</span><span>
 </span><span class="sgr-fg-b1"> [4ec0a83e] </span><span class="sgr-fg-b3">+ Unicode</span>
```

Now we activate the environment of `MyPackage`:

```terminal
<span class="sgr-bold sgr-fg-5">(@v1.8) pkg> </span><span>activate MyPackage
</span><span class="sgr-bold sgr-fg-3">  Activating</span><span> project at `~/MyPackage`
</span>
```

Let's see what happens if we load `Infiltrator`:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>using Infiltrator</span>
```

It worked.
But why?
`Infiltrator` is not available in `MyPackage`'s Project.toml.

The reason is that Julia can import packages from multiple environments at the same time.
This depends on the `LOAD_PATH` global variable.
Let's have a look:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>LOAD_PATH
3-element Vector{String}:
 "@"
 "@v#.#"
 "@stdlib"
</span>
```

The first entry, `"@"`, means "active environment", so the first place where Julia looked for Infiltrator was in `MyPackage`'s environment, where it didn't find it.

The second entry, `"@v#.#"` means "the shared environment of this Julia version", in our case this is `@v1.8`.
That's why I kept calling this the "main" environment, not only because it's the default one, but also because it's always available by default due to the `LOAD_PATH` configuration.
This is where Julia found `Infiltrator` and loaded it.

The third entry, `"@stdlib"`, refers to the list of standard libraries that belongs to the current Julia version.
This is the reason why we can do `using Statistics` or `using REPL` in a new Julia session, even if our main environment is empty.

The potential confusion comes from the fact that a user can activate a package environment and work there under the assumption that only package dependencies are available.
This might hide the fact that some of the included packages are drawn in from the main environment, which will lead to an error later, if the package is installed to a new environment and can't access the dependency anymore.

The best practice for stacked environments is to use the main environment sparingly.
`Infiltrator` is a good example for a package to install there, because it's a debugging package and basically never needed as a dependency for another package.
On the other hand it's very useful to have available without further work when developing.
Another example is `Revise`.

If you really want to make sure that only the packages from your currently activated project are accessible, you can remove other entries from the load path.

To demonstrate this, if we empty the load path we can't load any package at all, neither `Infiltrator` from `@v1.8`, nor `MyPackage` from our active environment, nor the standard library `Statistics`:

```terminal
<span class="sgr-bold sgr-fg-3">julia> </span><span>empty!(LOAD_PATH)
String[]

</span><span class="sgr-bold sgr-fg-3">julia> </span><span>using Infiltrator
</span><span class="sgr-fg-3"> │ </span><span>Package Infiltrator not found, but a package named Infiltrator is available
</span><span class="sgr-fg-3"> │ </span><span>from a registry. 
</span><span class="sgr-fg-3"> │ </span><span>Install package?
</span><span class="sgr-fg-3"> │   </span><span class="sgr-fg-5">(MyPackage) pkg> </span><span>add Infiltrator 
</span><span class="sgr-fg-3"> └ </span><span>(y/n/o) [y]: </span><span class="sgr-bold sgr-fg-b2">ERROR: </span><span>ArgumentError: Package Infiltrator not found in current path, maybe you meant `import/using .Infiltrator`.
- Otherwise, run `import Pkg; Pkg.add("Infiltrator")` to install the Infiltrator package.

<span class="sgr-bold sgr-fg-3">julia> </span><span>using MyPackage
</span><span class="sgr-bold sgr-fg-b2">ERROR: </span><span>ArgumentError: Package MyPackage not found in current path.
- Run `import Pkg; Pkg.add("MyPackage")` to install the MyPackage package.

<span class="sgr-bold sgr-fg-3">julia> </span><span>using Statistics
</span><span class="sgr-bold sgr-fg-b2">ERROR: </span><span>ArgumentError: Package Statistics not found in current path.
- Run `import Pkg; Pkg.add("Statistics")` to install the Statistics package.
</span>
```

## Temporary environments

One thing that's useful for quick tests are temporary environments.
If you read about a new package and quickly want to try it, but don't want to mess with your main environment or clutter your working directory with environment files, you can use `activate --temp`:

```terminal
<span class="sgr-bold sgr-fg-5">(v1.8) pkg> </span><span>activate --temp
</span><span class="sgr-bold sgr-fg-3">  Activating</span><span> new project at `/var/folders/z5/r5q6djwn5g10k3w279bn37700000gn/T/jl_e4klnB`

</span><span class="sgr-bold sgr-fg-5">(jl_e4klnB) pkg> </span>
```

This environment will only exist until the Julia process exits, so it's perfect to run something once and then forget about it.

## Conclusion

This was a short tour of `Pkg` and its main functions.
I hope it has become more clear how environments work and why you shouldn't rely on a single global one.
It's quite easy to make one environment per project and the text files created use effectively no space, so there's no downside to doing this.

For more info, have a look at some of these sources:

- [Pkg.jl documentation](https://pkgdocs.julialang.org/v1/).
- [DrWatson.jl](https://juliadynamics.github.io/DrWatson.jl/stable/), a tool that tries to make the process of setting up reproducible projects easier.
- [TestEnv.jl](https://github.com/JuliaTesting/TestEnv.jl) which helps with the problem of stacked environments in the context of tests (not covered here).
- [PkgTemplates.jl](https://github.com/invenia/PkgTemplates.jl) which makes creating packages easier.